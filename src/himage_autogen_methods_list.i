    {"MapImage", (PyCFunction)PyHirschImage_MapImage, METH_VARARGS, "MapImage(Map)\n\nApply a general transformation to an image." },
    {"VectorFieldLength", (PyCFunction)PyHirschImage_VectorFieldLength, METH_VARARGS, "VectorFieldLength(Mode)\n\nCompute the length of the vectors of a vector field." },
    {"SelectGrayvaluesFromChannels", (PyCFunction)PyHirschImage_SelectGrayvaluesFromChannels, METH_VARARGS, "SelectGrayvaluesFromChannels(IndexImage)\n\nSelection of gray values of a multi-channel image using an index image." },
    {"Pouring", (PyCFunction)PyHirschImage_Pouring, METH_VARARGS, "Pouring(Mode,MinGray,MaxGray)\n\nSegment an image by \"pouring water\" over it." },
    {"CreateUncalibDescriptorModel", (PyCFunction)PyHirschImage_CreateUncalibDescriptorModel, METH_VARARGS, "CreateUncalibDescriptorModel(DetectorType,DetectorParamName,DetectorParamValue,DescriptorParamName,DescriptorParamValue,Seed)\n\nPrepare a descriptor model for interest point matching." },
    {"ProjMatchPointsRansac", (PyCFunction)PyHirschImage_ProjMatchPointsRansac, METH_VARARGS, "ProjMatchPointsRansac(Image2,Rows1,Cols1,Rows2,Cols2,GrayMatchMethod,MaskSize,RowMove,ColMove,RowTolerance,ColTolerance,Rotation,MatchThreshold,EstimationMethod,DistanceThreshold,RandSeed)\n\nCompute a projective transformation matrix between two images by\nfinding correspondences between points." },
    {"MeanN", (PyCFunction)PyHirschImage_MeanN, METH_NOARGS, "MeanN()\n\nAverage gray values over several channels." },
    {"RobinsonDir", (PyCFunction)PyHirschImage_RobinsonDir, METH_NOARGS, "RobinsonDir()\n\nDetect edges (amplitude and direction) using the Robinson operator." },
    {"EstimateTiltLr", (PyCFunction)PyHirschImage_EstimateTiltLr, METH_NOARGS, "EstimateTiltLr()\n\nEstimate the tilt of a light source." },
    {"Compose4", (PyCFunction)PyHirschImage_Compose4, METH_VARARGS, "Compose4(Image2,Image3,Image4)\n\nConvert 4 images into a four-channel image." },
    {"Compose5", (PyCFunction)PyHirschImage_Compose5, METH_VARARGS, "Compose5(Image2,Image3,Image4,Image5)\n\nConvert 5 images into a five-channel image." },
    {"Compose6", (PyCFunction)PyHirschImage_Compose6, METH_VARARGS, "Compose6(Image2,Image3,Image4,Image5,Image6)\n\nConvert 6 images into a six-channel image." },
    {"Compose7", (PyCFunction)PyHirschImage_Compose7, METH_VARARGS, "Compose7(Image2,Image3,Image4,Image5,Image6,Image7)\n\nConvert 7 images into a seven-channel image." },
    {"Compose2", (PyCFunction)PyHirschImage_Compose2, METH_VARARGS, "Compose2(Image2)\n\nConvert two images into a two-channel image." },
    {"Compose3", (PyCFunction)PyHirschImage_Compose3, METH_VARARGS, "Compose3(Image2,Image3)\n\nConvert 3 images into a three-channel image." },
    {"BinThreshold", (PyCFunction)PyHirschImage_BinThreshold, METH_NOARGS, "BinThreshold()\n\nSegment an image using an automatically determined\nthreshold." },
    {"TopographicSketch", (PyCFunction)PyHirschImage_TopographicSketch, METH_NOARGS, "TopographicSketch()\n\nCompute the topographic primal sketch of an image." },
    {"MeanCurvatureFlow", (PyCFunction)PyHirschImage_MeanCurvatureFlow, METH_VARARGS, "MeanCurvatureFlow(Sigma,Theta,Iterations)\n\nApply the mean curvature flow to an image." },
    {"GraySkeleton", (PyCFunction)PyHirschImage_GraySkeleton, METH_NOARGS, "GraySkeleton()\n\nThinning of gray value images." },
    {"KirschAmp", (PyCFunction)PyHirschImage_KirschAmp, METH_NOARGS, "KirschAmp()\n\nDetect edges (amplitude) using the Kirsch operator." },
    {"GetGrayvalContourXld", (PyCFunction)PyHirschImage_GetGrayvalContourXld, METH_VARARGS, "GetGrayvalContourXld(Contour,Interpolation)\n\nReturn gray values of an image at the positions of an XLD contour." },
    {"FillInterlace", (PyCFunction)PyHirschImage_FillInterlace, METH_VARARGS, "FillInterlace(Mode)\n\nInterpolate 2 video half images." },
    {"BitAnd", (PyCFunction)PyHirschImage_BitAnd, METH_VARARGS, "BitAnd(Image2)\n\nBit-by-bit AND of all pixels of the input images." },
    {"ProjMatchPointsRansacGuided", (PyCFunction)PyHirschImage_ProjMatchPointsRansacGuided, METH_VARARGS, "ProjMatchPointsRansacGuided(Image2,Rows1,Cols1,Rows2,Cols2,GrayMatchMethod,MaskSize,HomMat2DGuide,DistanceTolerance,MatchThreshold,EstimationMethod,DistanceThreshold,RandSeed)\n\nCompute a projective transformation matrix between two images by\nfinding correspondences between points based on a known\napproximation of the projective transformation matrix." },
    {"CreateTemplate", (PyCFunction)PyHirschImage_CreateTemplate, METH_VARARGS, "CreateTemplate(FirstError,NumLevel,Optimize,GrayValues)\n\nPreparing a pattern for template matching." },
    {"SubImage", (PyCFunction)PyHirschImage_SubImage, METH_VARARGS, "SubImage(ImageSubtrahend,Mult,Add)\n\nSubtract two images." },
    {"ScaleImage", (PyCFunction)PyHirschImage_ScaleImage, METH_VARARGS, "ScaleImage(Mult,Add)\n\nScale the gray values of an image." },
    {"GenImage1Extern", (PyCFunction)PyHirschImage_GenImage1Extern, METH_STATIC|METH_VARARGS, "GenImage1Extern(Type,Width,Height,PixelPointer,ClearProc)\n\nCreate an image from a pointer on the pixels with storage management." },
    {"Lowlands", (PyCFunction)PyHirschImage_Lowlands, METH_NOARGS, "Lowlands()\n\nDetect all gray value lowlands." },
    {"GetDomain", (PyCFunction)PyHirschImage_GetDomain, METH_NOARGS, "GetDomain()\n\nGet the domain of an image." },
    {"RealToVectorField", (PyCFunction)PyHirschImage_RealToVectorField, METH_VARARGS, "RealToVectorField(Col)\n\nConvert two real-valued images into a vector field image." },
    {"Get1dBarCode", (PyCFunction)PyHirschImage_Get1dBarCode, METH_VARARGS, "Get1dBarCode(BarCodeDescr,GenericName,GenericValue,Orientation)\n\nExtract the widths of the elements inside a bar code region." },
    {"PowerLn", (PyCFunction)PyHirschImage_PowerLn, METH_NOARGS, "PowerLn()\n\nReturn the power spectrum of a complex image." },
    {"GenImage1", (PyCFunction)PyHirschImage_GenImage1, METH_STATIC|METH_VARARGS, "GenImage1(Type,Width,Height,PixelPointer)\n\nCreate an image from a pointer to the pixels." },
    {"SimulateMotion", (PyCFunction)PyHirschImage_SimulateMotion, METH_VARARGS, "SimulateMotion(Blurring,Angle,Type)\n\nSimulation of (linearly) motion blur." },
    {"AnisotropeDiff", (PyCFunction)PyHirschImage_AnisotropeDiff, METH_VARARGS, "AnisotropeDiff(Percent,Mode,Iteration,NeighborhoodType)\n\nSmooth an image by edge-preserving anisotropic diffusion." },
    {"CropDomainRel", (PyCFunction)PyHirschImage_CropDomainRel, METH_VARARGS, "CropDomainRel(Top,Left,Bottom,Right)\n\nCut out an image area relative to the domain." },
    {"CriticalPointsSubPix", (PyCFunction)PyHirschImage_CriticalPointsSubPix, METH_VARARGS, "CriticalPointsSubPix(Filter,Sigma,Threshold)\n\nSubpixel precise detection of critical points in an image." },
    {"SimCaltab", (PyCFunction)PyHirschImage_SimCaltab, METH_STATIC|METH_VARARGS, "SimCaltab(CalTabDescrFile,CamParam,CaltabPose,GrayBackground,GrayCaltab,GrayMarks,ScaleFac)\n\nSimulate an image with calibration plate." },
    {"CreateTemplateRot", (PyCFunction)PyHirschImage_CreateTemplateRot, METH_VARARGS, "CreateTemplateRot(NumLevel,AngleStart,AngleExtend,AngleStep,Optimize,GrayValues)\n\nPreparing a pattern for template matching with rotation." },
    {"CropPart", (PyCFunction)PyHirschImage_CropPart, METH_VARARGS, "CropPart(Row,Column,Width,Height)\n\nCut out a rectangular image area." },
    {"GenDerivativeFilter", (PyCFunction)PyHirschImage_GenDerivativeFilter, METH_STATIC|METH_VARARGS, "GenDerivativeFilter(Derivative,Exponent,Norm,Mode,Width,Height)\n\nGenerate a derivative filter in the frequency domain." },
    {"GrayRangeRect", (PyCFunction)PyHirschImage_GrayRangeRect, METH_VARARGS, "GrayRangeRect(MaskHeight,MaskWidth)\n\nDetermine the gray value range within a rectangle." },
    {"SaddlePointsSubPix", (PyCFunction)PyHirschImage_SaddlePointsSubPix, METH_VARARGS, "SaddlePointsSubPix(Filter,Sigma,Threshold)\n\nSubpixel precise detection of saddle points in an image." },
    {"FindBarCode", (PyCFunction)PyHirschImage_FindBarCode, METH_VARARGS, "FindBarCode(BarCodeHandle,CodeType)\n\nDetect and read bar code symbols in an image." },
    {"AdaptTemplate", (PyCFunction)PyHirschImage_AdaptTemplate, METH_VARARGS, "AdaptTemplate(TemplateID)\n\nAdapting a template to the size of an image." },
    {"HysteresisThreshold", (PyCFunction)PyHirschImage_HysteresisThreshold, METH_VARARGS, "HysteresisThreshold(Low,High,MaxLength)\n\nPerform a hysteresis threshold operation on an image." },
    {"PhaseDeg", (PyCFunction)PyHirschImage_PhaseDeg, METH_NOARGS, "PhaseDeg()\n\nReturn the phase of a complex image in degrees." },
    {"CropDomain", (PyCFunction)PyHirschImage_CropDomain, METH_NOARGS, "CropDomain()\n\nCut out of defined gray values." },
    {"SetPixVal", (PyCFunction)PyHirschImage_SetPixVal, METH_VARARGS, "SetPixVal(x,y,val)\n\n" },
    {"ThresholdSubPix", (PyCFunction)PyHirschImage_ThresholdSubPix, METH_VARARGS, "ThresholdSubPix(Threshold)\n\nExtract level crossings from an image with subpixel accuracy." },
    {"PowerReal", (PyCFunction)PyHirschImage_PowerReal, METH_NOARGS, "PowerReal()\n\nReturn the power spectrum of a complex image." },
    {"PointsLepetit", (PyCFunction)PyHirschImage_PointsLepetit, METH_VARARGS, "PointsLepetit(Radius,CheckNeighbor,MinCheckNeighborDiff,MinScore,Subpix)\n\nDetect points of interest using the Lepetit operator." },
    {"GenBandpass", (PyCFunction)PyHirschImage_GenBandpass, METH_STATIC|METH_VARARGS, "GenBandpass(MinFrequency,MaxFrequency,Norm,Mode,Width,Height)\n\nGenerate an ideal bandpass filter." },
    {"FftImage", (PyCFunction)PyHirschImage_FftImage, METH_NOARGS, "FftImage()\n\nCompute the fast Fourier transform of an image." },
    {"DetermineShapeModelParams", (PyCFunction)PyHirschImage_DetermineShapeModelParams, METH_VARARGS, "DetermineShapeModelParams(NumLevels,AngleStart,AngleExtent,ScaleMin,ScaleMax,Optimization,Metric,Contrast,MinContrast,Parameters)\n\nDetermine the parameters of a shape model." },
    {"ShockFilter", (PyCFunction)PyHirschImage_ShockFilter, METH_VARARGS, "ShockFilter(Theta,Iterations,Mode,Sigma)\n\nApply a shock filter to an image." },
    {"DotsImage", (PyCFunction)PyHirschImage_DotsImage, METH_VARARGS, "DotsImage(Diameter,FilterType,PixelShift)\n\nEnhance circular dots in an image." },
    {"EdgesColorSubPix", (PyCFunction)PyHirschImage_EdgesColorSubPix, METH_VARARGS, "EdgesColorSubPix(Filter,Alpha,Low,High)\n\nExtract subpixel precise color edges using Deriche, Shen, or Canny filters." },
    {"GetImagePointer3", (PyCFunction)PyHirschImage_GetImagePointer3, METH_NOARGS, "GetImagePointer3()\n\nAccess the pointers of a colored image." },
    {"FullDomain", (PyCFunction)PyHirschImage_FullDomain, METH_NOARGS, "FullDomain()\n\nExpand the domain of an image to maximum." },
    {"DerivateGauss", (PyCFunction)PyHirschImage_DerivateGauss, METH_VARARGS, "DerivateGauss(Sigma,Component)\n\nConvolve an image with derivatives of the Gaussian." },
    {"GetGrayval", (PyCFunction)PyHirschImage_GetGrayval, METH_VARARGS, "GetGrayval(Row,Column)\n\nAccess the gray values of an image object." },
    {"FastMatchMg", (PyCFunction)PyHirschImage_FastMatchMg, METH_VARARGS, "FastMatchMg(TemplateID,MaxError,NumLevel)\n\nSearching all good grayvalue matches in a pyramid." },
    {"DispChannel", (PyCFunction)PyHirschImage_DispChannel, METH_VARARGS, "DispChannel(WindowHandle,Channel)\n\nDisplays images with several channels." },
    {"NonmaxSuppressionAmp", (PyCFunction)PyHirschImage_NonmaxSuppressionAmp, METH_VARARGS, "NonmaxSuppressionAmp(Mode)\n\nSuppress non-maximum points on an edge." },
    {"ZeroCrossingSubPix", (PyCFunction)PyHirschImage_ZeroCrossingSubPix, METH_NOARGS, "ZeroCrossingSubPix()\n\nExtract zero crossings from an image with subpixel accuracy." },
    {"GenMeanFilter", (PyCFunction)PyHirschImage_GenMeanFilter, METH_STATIC|METH_VARARGS, "GenMeanFilter(MaskShape,Diameter1,Diameter2,Phi,Norm,Mode,Width,Height)\n\nGenerate a mean filter in the frequency domain." },
    {"HarmonicInterpolation", (PyCFunction)PyHirschImage_HarmonicInterpolation, METH_VARARGS, "HarmonicInterpolation(Region,Precision)\n\nPerform a harmonic interpolation on an image region." },
    {"TransToRgb", (PyCFunction)PyHirschImage_TransToRgb, METH_VARARGS, "TransToRgb(ImageInput2,ImageInput3,ColorSpace)\n\nTransform an image from an arbitrary color space to the RGB color space." },
    {"ProjectiveTransImage", (PyCFunction)PyHirschImage_ProjectiveTransImage, METH_VARARGS, "ProjectiveTransImage(HomMat2D,Interpolation,AdaptImageSize,TransformRegion)\n\nApply a projective transformation to an image." },
    {"EnergyGabor", (PyCFunction)PyHirschImage_EnergyGabor, METH_VARARGS, "EnergyGabor(ImageHilbert)\n\nCalculate the energy of a two-channel image." },
    {"Laplace", (PyCFunction)PyHirschImage_Laplace, METH_VARARGS, "Laplace(ResultType,MaskSize,FilterMask)\n\nCalculate the Laplace operator by using finite differences." },
    {"HoughLinesDir", (PyCFunction)PyHirschImage_HoughLinesDir, METH_VARARGS, "HoughLinesDir(DirectionUncertainty,AngleResolution,Smoothing,FilterSize,Threshold,AngleGap,DistGap,GenLines)\n\nDetect lines in edge images with the help of the Hough transform \nusing local gradient direction and return them in normal form." },
    {"AffineTransImage", (PyCFunction)PyHirschImage_AffineTransImage, METH_VARARGS, "AffineTransImage(HomMat2D,Interpolation,AdaptImageSize)\n\nApply an arbitrary affine 2D transformation to images." },
    {"GenRadialDistortionMap", (PyCFunction)PyHirschImage_GenRadialDistortionMap, METH_STATIC|METH_VARARGS, "GenRadialDistortionMap(CamParamIn,CamParamOut,Interpolation)\n\nGenerate a projection map that describes the mapping of images corresponding\nto a changing radial distortion." },
    {"HClassName", (PyCFunction)PyHirschImage_HClassName, METH_NOARGS, "HClassName()\n\n" },
    {"Height", (PyCFunction)PyHirschImage_Height, METH_NOARGS, "Height()\n\n" },
    {"BitMask", (PyCFunction)PyHirschImage_BitMask, METH_VARARGS, "BitMask(BitMask)\n\nLogical \"AND\" of each pixel using a bit mask." },
    {"BestMatch", (PyCFunction)PyHirschImage_BestMatch, METH_VARARGS, "BestMatch(TemplateID,MaxError,SubPixel)\n\nSearching the best matching of a template and an image." },
    {"VectorFieldToReal", (PyCFunction)PyHirschImage_VectorFieldToReal, METH_NOARGS, "VectorFieldToReal()\n\nConvert a vector field image into two real-valued images." },
    {"LutTrans", (PyCFunction)PyHirschImage_LutTrans, METH_VARARGS, "LutTrans(Lut)\n\nTransform an image with a gray-value look-up-table" },
    {"TransFromRgb", (PyCFunction)PyHirschImage_TransFromRgb, METH_VARARGS, "TransFromRgb(ImageGreen,ImageBlue,ColorSpace)\n\nTransform an image from the RGB color space to an arbitrary color space." },
    {"DualRank", (PyCFunction)PyHirschImage_DualRank, METH_VARARGS, "DualRank(MaskType,Radius,ModePercent,Margin)\n\nOpening, Median and Closing with circle or rectangle mask." },
    {"EstimateSlAlLr", (PyCFunction)PyHirschImage_EstimateSlAlLr, METH_NOARGS, "EstimateSlAlLr()\n\nEstimate the slant of a light source and the albedo of a surface." },
    {"EdgesImage", (PyCFunction)PyHirschImage_EdgesImage, METH_VARARGS, "EdgesImage(Filter,Alpha,NMS,Low,High)\n\nExtract edges using Deriche, Lanser, Shen, or Canny filters." },
    {"CopyImage", (PyCFunction)PyHirschImage_CopyImage, METH_NOARGS, "CopyImage()\n\nCopy an image and allocate new memory for it." },
    {"RankImage", (PyCFunction)PyHirschImage_RankImage, METH_VARARGS, "RankImage(Mask,Rank,Margin)\n\nSmooth an image with an arbitrary rank mask." },
    {"PointsFoerstner", (PyCFunction)PyHirschImage_PointsFoerstner, METH_VARARGS, "PointsFoerstner(SigmaGrad,SigmaInt,SigmaPoints,ThreshInhom,ThreshShape,Smoothing,EliminateDoublets)\n\nDetect points of interest using the Foerstner operator." },
    {"GrayDilation", (PyCFunction)PyHirschImage_GrayDilation, METH_VARARGS, "GrayDilation(SE)\n\nPerform a gray value dilation on an image." },
    {"RealToComplex", (PyCFunction)PyHirschImage_RealToComplex, METH_VARARGS, "RealToComplex(ImageImaginary)\n\nConvert two real images into a complex image." },
    {"MatchFundamentalMatrixRansac", (PyCFunction)PyHirschImage_MatchFundamentalMatrixRansac, METH_VARARGS, "MatchFundamentalMatrixRansac(Image2,Rows1,Cols1,Rows2,Cols2,GrayMatchMethod,MaskSize,RowMove,ColMove,RowTolerance,ColTolerance,Rotation,MatchThreshold,EstimationMethod,DistanceThreshold,RandSeed)\n\nCompute the fundamental matrix for a pair of stereo images by\nautomatically finding correspondences between image\npoints." },
    {"ShadeHeightField", (PyCFunction)PyHirschImage_ShadeHeightField, METH_VARARGS, "ShadeHeightField(Slant,Tilt,Albedo,Ambient,Shadows)\n\nShade a height field." },
    {"BestMatchMg", (PyCFunction)PyHirschImage_BestMatchMg, METH_VARARGS, "BestMatchMg(TemplateID,MaxError,SubPixel,NumLevels,WhichLevels)\n\nSearching the best grayvalue matches in a pyramid." },
    {"FastMatch", (PyCFunction)PyHirschImage_FastMatch, METH_VARARGS, "FastMatch(TemplateID,MaxError)\n\nSearching all good matches of a template and an image." },
    {"DeviationImage", (PyCFunction)PyHirschImage_DeviationImage, METH_VARARGS, "DeviationImage(Width,Height)\n\nCalculate the standard deviation of gray values within rectangular windows." },
    {"SobelDir", (PyCFunction)PyHirschImage_SobelDir, METH_VARARGS, "SobelDir(FilterType,Size)\n\nDetect edges (amplitude and direction) using the Sobel operator." },
    {"ProjectiveTransImageSize", (PyCFunction)PyHirschImage_ProjectiveTransImageSize, METH_VARARGS, "ProjectiveTransImageSize(HomMat2D,Interpolation,Width,Height,TransformRegion)\n\nApply a projective transformation to an image and specify the output\nimage size." },
    {"GrayOpeningShape", (PyCFunction)PyHirschImage_GrayOpeningShape, METH_VARARGS, "GrayOpeningShape(MaskHeight,MaskWidth,MaskShape)\n\nPerform a gray value opening with a selected mask." },
    {"ConvertImageType", (PyCFunction)PyHirschImage_ConvertImageType, METH_VARARGS, "ConvertImageType(NewType)\n\nConvert the type of an image." },
    {"FindRectificationGrid", (PyCFunction)PyHirschImage_FindRectificationGrid, METH_VARARGS, "FindRectificationGrid(MinContrast,Radius)\n\nSegment the rectification grid region in the image." },
    {"DetectEdgeSegments", (PyCFunction)PyHirschImage_DetectEdgeSegments, METH_VARARGS, "DetectEdgeSegments(SobelSize,MinAmplitude,MaxDistance,MinLength)\n\nDetect straight edge segments." },
    {"Rgb3ToGray", (PyCFunction)PyHirschImage_Rgb3ToGray, METH_VARARGS, "Rgb3ToGray(ImageGreen,ImageBlue)\n\nTransform an RGB image to a gray scale image." },
    {"LocalMaxSubPix", (PyCFunction)PyHirschImage_LocalMaxSubPix, METH_VARARGS, "LocalMaxSubPix(Filter,Sigma,Threshold)\n\nSubpixel precise detection of local maxima in an image." },
    {"GetImageTime", (PyCFunction)PyHirschImage_GetImageTime, METH_NOARGS, "GetImageTime()\n\nRequest time at which the image was created." },
    {"EdgesColor", (PyCFunction)PyHirschImage_EdgesColor, METH_VARARGS, "EdgesColor(Filter,Alpha,NMS,Low,High)\n\nExtract color edges using Canny, Deriche, or Shen filters." },
    {"LabelToRegion", (PyCFunction)PyHirschImage_LabelToRegion, METH_NOARGS, "LabelToRegion()\n\nExtract regions with equal gray values from an image." },
    {"ConvolGabor", (PyCFunction)PyHirschImage_ConvolGabor, METH_VARARGS, "ConvolGabor(GaborFilter)\n\nConvolve an image with a Gabor filter in the frequency domain." },
    {"MaxImage", (PyCFunction)PyHirschImage_MaxImage, METH_VARARGS, "MaxImage(Image2)\n\nCalculate the maximum of two images pixel by pixel." },
    {"GrayErosionShape", (PyCFunction)PyHirschImage_GrayErosionShape, METH_VARARGS, "GrayErosionShape(MaskHeight,MaskWidth,MaskShape)\n\nDetermine the minimum gray value within a selected mask." },
    {"InvertImage", (PyCFunction)PyHirschImage_InvertImage, METH_NOARGS, "InvertImage()\n\nInvert an image." },
    {"Regiongrowing", (PyCFunction)PyHirschImage_Regiongrowing, METH_VARARGS, "Regiongrowing(Row,Column,Tolerance,MinSize)\n\nSegment an image using regiongrowing." },
    {"DiffOfGauss", (PyCFunction)PyHirschImage_DiffOfGauss, METH_VARARGS, "DiffOfGauss(Sigma,SigFactor)\n\nApproximate the LoG operator (Laplace of Gaussian)." },
    {"GrayErosion", (PyCFunction)PyHirschImage_GrayErosion, METH_VARARGS, "GrayErosion(SE)\n\nPerform a gray value erosion on an image." },
    {"BitLshift", (PyCFunction)PyHirschImage_BitLshift, METH_VARARGS, "BitLshift(Shift)\n\nLeft shift of all pixels of the image." },
    {"GrayErosionRect", (PyCFunction)PyHirschImage_GrayErosionRect, METH_VARARGS, "GrayErosionRect(MaskHeight,MaskWidth)\n\nDetermine the minimum gray value within a rectangle." },
    {"Symmetry", (PyCFunction)PyHirschImage_Symmetry, METH_VARARGS, "Symmetry(MaskSize,Direction,Exponent)\n\nSymmetry of gray values along a row." },
    {"GenGaussPyramid", (PyCFunction)PyHirschImage_GenGaussPyramid, METH_VARARGS, "GenGaussPyramid(Mode,Scale)\n\nCalculating a Gauss pyramid." },
    {"CreateCalibDescriptorModel", (PyCFunction)PyHirschImage_CreateCalibDescriptorModel, METH_VARARGS, "CreateCalibDescriptorModel(CamParam,ReferencePose,DetectorType,DetectorParamName,DetectorParamValue,DescriptorParamName,DescriptorParamValue,Seed)\n\nCreate a descriptor model for calibrated perspective matching." },
    {"EstimateTiltZc", (PyCFunction)PyHirschImage_EstimateTiltZc, METH_NOARGS, "EstimateTiltZc()\n\nEstimate the tilt of a light source." },
    {"GenImage1Rect", (PyCFunction)PyHirschImage_GenImage1Rect, METH_STATIC|METH_VARARGS, "GenImage1Rect(PixelPointer,Width,Height,VerticalPitch,HorizontalBitPitch,BitsPerPixel,DoCopy,ClearProc)\n\nCreate an image with a rectangular domain from a pointer on the pixels\n(with storage management)." },
    {"MatchEssentialMatrixRansac", (PyCFunction)PyHirschImage_MatchEssentialMatrixRansac, METH_VARARGS, "MatchEssentialMatrixRansac(Image2,Rows1,Cols1,Rows2,Cols2,CamMat1,CamMat2,GrayMatchMethod,MaskSize,RowMove,ColMove,RowTolerance,ColTolerance,Rotation,MatchThreshold,EstimationMethod,DistanceThreshold,RandSeed)\n\nCompute the essential matrix for a pair of stereo images by automatically \nfinding correspondences between image points." },
    {"MultImage", (PyCFunction)PyHirschImage_MultImage, METH_VARARGS, "MultImage(Image2,Mult,Add)\n\nMultiply two images." },
    {"SfsPentland", (PyCFunction)PyHirschImage_SfsPentland, METH_VARARGS, "SfsPentland(Slant,Tilt,Albedo,Ambient)\n\nReconstruct a surface from a gray value image." },
    {"BinocularDistanceMg", (PyCFunction)PyHirschImage_BinocularDistanceMg, METH_VARARGS, "BinocularDistanceMg(Image2,CamParamRect1,CamParamRect2,RelPoseRect,GrayConstancy,GradientConstancy,Smoothness,InitialGuess,CalculateScore,MGParamName,MGParamValue)\n\nCompute the distance values for a rectified stereo image pair using \nmultigrid methods." },
    {"GrayOpeningRect", (PyCFunction)PyHirschImage_GrayOpeningRect, METH_VARARGS, "GrayOpeningRect(MaskHeight,MaskWidth)\n\nPerform a gray value opening with a rectangular mask." },
    {"PhaseRad", (PyCFunction)PyHirschImage_PhaseRad, METH_NOARGS, "PhaseRad()\n\nReturn the phase of a complex image in radians." },
    {"FastThreshold", (PyCFunction)PyHirschImage_FastThreshold, METH_VARARGS, "FastThreshold(MinGray,MaxGray,MinSize)\n\nFast thresholding of images using global thresholds." },
    {"GenImageConst", (PyCFunction)PyHirschImage_GenImageConst, METH_STATIC|METH_VARARGS, "GenImageConst(Type,Width,Height)\n\nCreate an image with constant gray value." },
    {"AddNoiseWhite", (PyCFunction)PyHirschImage_AddNoiseWhite, METH_VARARGS, "AddNoiseWhite(Amp)\n\nAdd noise to an image." },
    {"LocalMax", (PyCFunction)PyHirschImage_LocalMax, METH_NOARGS, "LocalMax()\n\nDetect all local maxima in an image." },
    {"EliminateMinMax", (PyCFunction)PyHirschImage_EliminateMinMax, METH_VARARGS, "EliminateMinMax(MaskWidth,MaskHeight,Gap,Mode)\n\nSmooth an image in the spatial domain to suppress noise." },
    {"OpticalFlowMg", (PyCFunction)PyHirschImage_OpticalFlowMg, METH_VARARGS, "OpticalFlowMg(Image2,Algorithm,SmoothingSigma,IntegrationSigma,FlowSmoothness,GradientConstancy,MGParamName,MGParamValue)\n\nCompute the optical flow between two images." },
    {"RotateImage", (PyCFunction)PyHirschImage_RotateImage, METH_VARARGS, "RotateImage(Phi,Interpolation)\n\nRotate an image about its center." },
    {"VectorFieldToHomMat2d", (PyCFunction)PyHirschImage_VectorFieldToHomMat2d, METH_NOARGS, "VectorFieldToHomMat2d()\n\nApproximate an affine map from a displacement vector field." },
    {"CorrelationFft", (PyCFunction)PyHirschImage_CorrelationFft, METH_VARARGS, "CorrelationFft(ImageFFT2)\n\nCompute the correlation of two images in the frequency domain." },
    {"VarThreshold", (PyCFunction)PyHirschImage_VarThreshold, METH_VARARGS, "VarThreshold(MaskWidth,MaskHeight,StdDevScale,AbsThreshold,LightDark)\n\nThreshold an image by local mean and standard deviation analysis." },
    {"LinesColor", (PyCFunction)PyHirschImage_LinesColor, METH_VARARGS, "LinesColor(Sigma,Low,High,ExtractWidth,CompleteJunctions)\n\nDetect color lines and their width." },
    {"GenGabor", (PyCFunction)PyHirschImage_GenGabor, METH_STATIC|METH_VARARGS, "GenGabor(Angle,Frequency,Bandwidth,Orientation,Norm,Mode,Width,Height)\n\nGenerate a Gabor filter." },
    {"ChangeRadialDistortionImage", (PyCFunction)PyHirschImage_ChangeRadialDistortionImage, METH_VARARGS, "ChangeRadialDistortionImage(Region,CamParamIn,CamParamOut)\n\nChange the radial distortion of an image." },
    {"GenSinBandpass", (PyCFunction)PyHirschImage_GenSinBandpass, METH_STATIC|METH_VARARGS, "GenSinBandpass(Frequency,Norm,Mode,Width,Height)\n\nGenerate a bandpass filter with sinusoidal shape." },
    {"NumImageRefs", (PyCFunction)PyHirschImage_NumImageRefs, METH_NOARGS, "NumImageRefs()\n\n" },
    {"CropRectangle1", (PyCFunction)PyHirschImage_CropRectangle1, METH_VARARGS, "CropRectangle1(Row1,Column1,Row2,Column2)\n\nCut out a rectangular image area." },
    {"ChangeDomain", (PyCFunction)PyHirschImage_ChangeDomain, METH_VARARGS, "ChangeDomain(NewDomain)\n\nChange definition domain of an image." },
    {"InpaintingCt", (PyCFunction)PyHirschImage_InpaintingCt, METH_VARARGS, "InpaintingCt(Region,Epsilon,Kappa,Sigma,Rho,ChannelCoefficients)\n\nPerform an inpainting by coherence transport." },
    {"OverpaintRegion", (PyCFunction)PyHirschImage_OverpaintRegion, METH_VARARGS, "OverpaintRegion(Region,Grayval,Type)\n\nOverpaint regions in an image." },
    {"ConvolFft", (PyCFunction)PyHirschImage_ConvolFft, METH_VARARGS, "ConvolFft(ImageFilter)\n\nConvolve an image with a filter in the frequency domain." },
    {"ImageToChannels", (PyCFunction)PyHirschImage_ImageToChannels, METH_NOARGS, "ImageToChannels()\n\nConvert a multichannel image into One-channel images" },
    {"GenImage3", (PyCFunction)PyHirschImage_GenImage3, METH_STATIC|METH_VARARGS, "GenImage3(Type,Width,Height,PixelPointerRed,PixelPointerGreen,PixelPointerBlue)\n\nCreate an image from three pointers to the pixels (red/green/blue)." },
    {"MedianWeighted", (PyCFunction)PyHirschImage_MedianWeighted, METH_VARARGS, "MedianWeighted(MaskType,MaskSize)\n\nWeighted median filtering with different rank masks." },
    {"GenImage3Extern", (PyCFunction)PyHirschImage_GenImage3Extern, METH_STATIC|METH_VARARGS, "GenImage3Extern(Type,Width,Height,PointerRed,PointerGreen,PointerBlue,ClearProc)\n\nCreate a three-channel image from three pointers on the pixels with storage\nmanagement." },
    {"EdgesSubPix", (PyCFunction)PyHirschImage_EdgesSubPix, METH_VARARGS, "EdgesSubPix(Filter,Alpha,Low,High)\n\nExtract sub-pixel precise edges using Deriche, Lanser, Shen, or Canny\nfilters." },
    {"GetImagePointer1", (PyCFunction)PyHirschImage_GetImagePointer1, METH_NOARGS, "GetImagePointer1()\n\nAccess the pointer of a channel." },
    {"Monotony", (PyCFunction)PyHirschImage_Monotony, METH_NOARGS, "Monotony()\n\nCalculating the monotony operation." },
    {"RegiongrowingMean", (PyCFunction)PyHirschImage_RegiongrowingMean, METH_VARARGS, "RegiongrowingMean(StartRows,StartColumns,Tolerance,MinSize)\n\nPerform a regiongrowing using mean gray values." },
    {"GenInitialComponents", (PyCFunction)PyHirschImage_GenInitialComponents, METH_VARARGS, "GenInitialComponents(ContrastLow,ContrastHigh,MinSize,Mode,GenericName,GenericValue)\n\nExtract the initial components of a component model." },
    {"SfsOrigLr", (PyCFunction)PyHirschImage_SfsOrigLr, METH_VARARGS, "SfsOrigLr(Slant,Tilt,Albedo,Ambient)\n\nReconstruct a surface from a gray value image." },
    {"ExhaustiveMatchMg", (PyCFunction)PyHirschImage_ExhaustiveMatchMg, METH_VARARGS, "ExhaustiveMatchMg(ImageTemplate,Mode,Level,Threshold)\n\nMatching a template and an image in a resolution pyramid." },
    {"AccessChannel", (PyCFunction)PyHirschImage_AccessChannel, METH_VARARGS, "AccessChannel(Channel)\n\nAccess a channel of a multichannel image." },
    {"EstimateSlAlZc", (PyCFunction)PyHirschImage_EstimateSlAlZc, METH_NOARGS, "EstimateSlAlZc()\n\nEstimate the slant of a light source and the albedo of a surface." },
    {"GenImageSurfaceSecondOrder", (PyCFunction)PyHirschImage_GenImageSurfaceSecondOrder, METH_STATIC|METH_VARARGS, "GenImageSurfaceSecondOrder(Type,Alpha,Beta,Gamma,Delta,Epsilon,Zeta,Row,Col,Width,Height)\n\nCreate a curved gray surface with second order polynomial." },
    {"HoughLineTransDir", (PyCFunction)PyHirschImage_HoughLineTransDir, METH_VARARGS, "HoughLineTransDir(DirectionUncertainty,AngleResolution)\n\nCompute the Hough transform for lines using local gradient direction." },
    {"Creator", (PyCFunction)PyHirschImage_Creator, METH_NOARGS, "Creator()\n\nTools" },
    {"MedianImage", (PyCFunction)PyHirschImage_MedianImage, METH_VARARGS, "MedianImage(MaskType,Radius,Margin)\n\nMedian filtering with different rank masks." },
    {"InpaintingMcf", (PyCFunction)PyHirschImage_InpaintingMcf, METH_VARARGS, "InpaintingMcf(Region,Sigma,Theta,Iterations)\n\nPerform an inpainting by smoothing of level lines." },
    {"Emphasize", (PyCFunction)PyHirschImage_Emphasize, METH_VARARGS, "Emphasize(MaskWidth,MaskHeight,Factor)\n\nEnhance contrast of the image." },
    {"LinearTransColor", (PyCFunction)PyHirschImage_LinearTransColor, METH_VARARGS, "LinearTransColor(TransMat)\n\nCompute an affine transformation of the color values of a\nmultichannel image." },
    {"InpaintingCed", (PyCFunction)PyHirschImage_InpaintingCed, METH_VARARGS, "InpaintingCed(Region,Sigma,Rho,Theta,Iterations)\n\nPerform an inpainting by coherence enhancing diffusion." },
    {"UnwarpImageVectorField", (PyCFunction)PyHirschImage_UnwarpImageVectorField, METH_VARARGS, "UnwarpImageVectorField(VectorField)\n\nUnwarp an image using a vector field." },
    {"PolarTransImage", (PyCFunction)PyHirschImage_PolarTransImage, METH_VARARGS, "PolarTransImage(Row,Column,Width,Height)\n\nTransform an image to polar coordinates" },
    {"GenGaussFilter", (PyCFunction)PyHirschImage_GenGaussFilter, METH_STATIC|METH_VARARGS, "GenGaussFilter(Sigma1,Sigma2,Phi,Norm,Mode,Width,Height)\n\nGenerate a Gaussian filter in the frequency domain." },
    {"LaplaceOfGauss", (PyCFunction)PyHirschImage_LaplaceOfGauss, METH_VARARGS, "LaplaceOfGauss(Sigma)\n\nLoG-Operator (Laplace of Gaussian)." },
    {"MedianSeparate", (PyCFunction)PyHirschImage_MedianSeparate, METH_VARARGS, "MedianSeparate(MaskWidth,MaskHeight,Margin)\n\nSeparated median filtering with rectangle masks." },
    {"GetImagePointer1Rect", (PyCFunction)PyHirschImage_GetImagePointer1Rect, METH_NOARGS, "GetImagePointer1Rect()\n\nAccess to the image data pointer and the image data inside \nthe smallest rectangle of the domain of the input image." },
    {"BitNot", (PyCFunction)PyHirschImage_BitNot, METH_NOARGS, "BitNot()\n\nComplement all bits of the pixels." },
    {"GetPixVal", (PyCFunction)PyHirschImage_GetPixVal, METH_VARARGS, "GetPixVal(x,y)\n\nPixel Access" },
    {"FftGeneric", (PyCFunction)PyHirschImage_FftGeneric, METH_VARARGS, "FftGeneric(Direction,Exponent,Norm,Mode,ResultType)\n\nCompute the fast Fourier transform of an image." },
    {"BinocularDistance", (PyCFunction)PyHirschImage_BinocularDistance, METH_VARARGS, "BinocularDistance(Image2,CamParamRect1,CamParamRect2,RelPoseRect,Method,MaskWidth,MaskHeight,TextureThresh,MinDisparity,MaxDisparity,NumLevels,ScoreThresh,Filter,SubDistance)\n\nCompute the distance values for a rectified stereo image pair using correlation\ntechniques." },
    {"DualThreshold", (PyCFunction)PyHirschImage_DualThreshold, METH_VARARGS, "DualThreshold(MinSize,MinGray,Threshold)\n\nThreshold operator for signed images." },
    {"GenImageToWorldPlaneMap", (PyCFunction)PyHirschImage_GenImageToWorldPlaneMap, METH_STATIC|METH_VARARGS, "GenImageToWorldPlaneMap(CamParam,WorldPose,WidthIn,HeightIn,WidthMapped,HeightMapped,Scale,Interpolation)\n\nGenerate a projection map that describes the mapping between the image\nplane and a the plane z=0 of a world coordinate system." },
    {"CoherenceEnhancingDiff", (PyCFunction)PyHirschImage_CoherenceEnhancingDiff, METH_VARARGS, "CoherenceEnhancingDiff(Sigma,Rho,Theta,Iterations)\n\nPerform a coherence enhancing diffusion of an image." },
    {"FindDataCode2d", (PyCFunction)PyHirschImage_FindDataCode2d, METH_VARARGS, "FindDataCode2d(DataCodeHandle,GenParamNames,GenParamValues)\n\nDetect and read 2D data code symbols in an image or\ntrain the 2D data code model." },
    {"SimulateDefocus", (PyCFunction)PyHirschImage_SimulateDefocus, METH_VARARGS, "SimulateDefocus(Blurring)\n\nSimulate an uniform out-of-focus blurring of an image." },
    {"GrayBothat", (PyCFunction)PyHirschImage_GrayBothat, METH_VARARGS, "GrayBothat(SE)\n\nPerform a gray value bottom hat transformation on an image." },
    {"OverpaintGray", (PyCFunction)PyHirschImage_OverpaintGray, METH_VARARGS, "OverpaintGray(ImageSource)\n\nOverpaint the gray values of an image." },
    {"ImageToWorldPlane", (PyCFunction)PyHirschImage_ImageToWorldPlane, METH_VARARGS, "ImageToWorldPlane(CamParam,WorldPose,Width,Height,Scale,Interpolation)\n\nRectify an image by transforming it into the plane z=0 of a world coordinate system." },
    {"CfaToRgb", (PyCFunction)PyHirschImage_CfaToRgb, METH_VARARGS, "CfaToRgb(CFAType,Interpolation)\n\nConvert a single-channel color filter array image into an RGB image." },
    {"GenLowpass", (PyCFunction)PyHirschImage_GenLowpass, METH_STATIC|METH_VARARGS, "GenLowpass(Frequency,Norm,Mode,Width,Height)\n\nGenerate an ideal lowpass filter." },
    {"TrimmedMean", (PyCFunction)PyHirschImage_TrimmedMean, METH_VARARGS, "TrimmedMean(Mask,Number,Margin)\n\nSmooth an image with an arbitrary rank mask." },
    {"BandpassImage", (PyCFunction)PyHirschImage_BandpassImage, METH_VARARGS, "BandpassImage(FilterType)\n\nEdge extraction using bandpass filters." },
    {"Width", (PyCFunction)PyHirschImage_Width, METH_NOARGS, "Width()\n\n" },
    {"TileChannels", (PyCFunction)PyHirschImage_TileChannels, METH_VARARGS, "TileChannels(NumColumns,TileOrder)\n\nTile multiple images into a large image." },
    {"ClassDBID", (PyCFunction)PyHirschImage_ClassDBID, METH_NOARGS, "ClassDBID()\n\n" },
    {"BinomialFilter", (PyCFunction)PyHirschImage_BinomialFilter, METH_VARARGS, "BinomialFilter(MaskWidth,MaskHeight)\n\nSmooth an image using the binomial filter." },
    {"HighpassImage", (PyCFunction)PyHirschImage_HighpassImage, METH_VARARGS, "HighpassImage(Width,Height)\n\nExtract high frequency components from an image." },
    {"PrincipalComp", (PyCFunction)PyHirschImage_PrincipalComp, METH_NOARGS, "PrincipalComp()\n\nCompute the principal components of multichannel images." },
    {"GetGrayvalInterpolated", (PyCFunction)PyHirschImage_GetGrayvalInterpolated, METH_VARARGS, "GetGrayvalInterpolated(Row,Column,Interpolation)\n\nReturn gray values of an image at the positions given by tuples of\nrows and columns." },
    {"PlateausCenter", (PyCFunction)PyHirschImage_PlateausCenter, METH_NOARGS, "PlateausCenter()\n\nDetect the centers of all gray value plateaus." },
    {"NumData", (PyCFunction)PyHirschImage_NumData, METH_STATIC|METH_NOARGS, "NumData()\n\nClass Methods" },
    {"ConnectGridPoints", (PyCFunction)PyHirschImage_ConnectGridPoints, METH_VARARGS, "ConnectGridPoints(Row,Col,Sigma,MaxDist)\n\nEstablish connections between the grid points of the rectification grid." },
    {"PrewittAmp", (PyCFunction)PyHirschImage_PrewittAmp, METH_NOARGS, "PrewittAmp()\n\nDetect edges (amplitude) using the Prewitt operator." },
    {"AbsImage", (PyCFunction)PyHirschImage_AbsImage, METH_NOARGS, "AbsImage()\n\nCalculate the absolute value (modulus) of an image." },
    {"DepthFromFocus", (PyCFunction)PyHirschImage_DepthFromFocus, METH_VARARGS, "DepthFromFocus(Filter,Selection)\n\nExtract depth using mutiple focus levels." },
    {"PhotStereo", (PyCFunction)PyHirschImage_PhotStereo, METH_VARARGS, "PhotStereo(Slants,Tilts)\n\nReconstruct a surface from at least three gray value images." },
    {"ComplexToReal", (PyCFunction)PyHirschImage_ComplexToReal, METH_NOARGS, "ComplexToReal()\n\nConvert a complex image into two real images." },
    {"DetermineDeformableModelParams", (PyCFunction)PyHirschImage_DetermineDeformableModelParams, METH_VARARGS, "DetermineDeformableModelParams(NumLevels,AngleStart,AngleExtent,ScaleMin,ScaleMax,Optimization,Metric,Contrast,MinContrast,ParamName,ParamValue,Parameters)\n\nDetermine the parameters of a deformable model." },
    {"Find1dBarCodeScanline", (PyCFunction)PyHirschImage_Find1dBarCodeScanline, METH_VARARGS, "Find1dBarCodeScanline(BarCodeDescr,GenericName,GenericValue,StopIfFound)\n\nLook for one bar code in an image." },
    {"SmoothImage", (PyCFunction)PyHirschImage_SmoothImage, METH_VARARGS, "SmoothImage(Filter,Alpha)\n\nSmooth an image using recursive filters." },
    {"FreiAmp", (PyCFunction)PyHirschImage_FreiAmp, METH_NOARGS, "FreiAmp()\n\nDetect edges (amplitude) using the Frei-Chen operator." },
    {"Class2dimUnsup", (PyCFunction)PyHirschImage_Class2dimUnsup, METH_VARARGS, "Class2dimUnsup(Image2,Threshold,NumClasses)\n\nSegment two images by clustering." },
    {"IsotropicDiffusion", (PyCFunction)PyHirschImage_IsotropicDiffusion, METH_VARARGS, "IsotropicDiffusion(Sigma,Iterations)\n\nPerform an isotropic diffusion of an image." },
    {"Rectangle1Domain", (PyCFunction)PyHirschImage_Rectangle1Domain, METH_VARARGS, "Rectangle1Domain(Row1,Column1,Row2,Column2)\n\nReduce the domain of an image to a rectangle." },
    {"TileImagesOffset", (PyCFunction)PyHirschImage_TileImagesOffset, METH_VARARGS, "TileImagesOffset(OffsetRow,OffsetCol,Row1,Col1,Row2,Col2,Width,Height)\n\nTile multiple image objects into a large image with explicit\npositioning information." },
    {"RobinsonAmp", (PyCFunction)PyHirschImage_RobinsonAmp, METH_NOARGS, "RobinsonAmp()\n\nDetect edges (amplitude) using the Robinson operator." },
    {"LocalMin", (PyCFunction)PyHirschImage_LocalMin, METH_NOARGS, "LocalMin()\n\nDetect all local minima in an image." },
    {"Find1dBarCodeRegion", (PyCFunction)PyHirschImage_Find1dBarCodeRegion, METH_VARARGS, "Find1dBarCodeRegion(BarCodeDescr,GenericName,GenericValue)\n\nLook for multiple bar code regions in an image." },
    {"SqrtImage", (PyCFunction)PyHirschImage_SqrtImage, METH_NOARGS, "SqrtImage()\n\nCalculate the square root of an image." },
    {"GenBinocularProjRectification", (PyCFunction)PyHirschImage_GenBinocularProjRectification, METH_STATIC|METH_VARARGS, "GenBinocularProjRectification(FMatrix,CovFMat,Width1,Height1,Width2,Height2,SubSampling,Mapping)\n\nCompute the projective rectification of weakly calibrated binocular\nstereo images." },
    {"PointsHarris", (PyCFunction)PyHirschImage_PointsHarris, METH_VARARGS, "PointsHarris(SigmaGrad,SigmaSmooth,Alpha,Threshold)\n\nDetect points of interest using the Harris operator." },
    {"CountChannels", (PyCFunction)PyHirschImage_CountChannels, METH_NOARGS, "CountChannels()\n\nCount channels of image." },
    {"GenImageSurfaceFirstOrder", (PyCFunction)PyHirschImage_GenImageSurfaceFirstOrder, METH_STATIC|METH_VARARGS, "GenImageSurfaceFirstOrder(Type,Alpha,Beta,Gamma,Row,Col,Width,Height)\n\nCreate a tilted gray surface with first order polynomial." },
    {"WienerFilterNi", (PyCFunction)PyHirschImage_WienerFilterNi, METH_VARARGS, "WienerFilterNi(Psf,NoiseRegion,MaskWidth,MaskHeight)\n\nImage restoration by Wiener filtering." },
    {"Plateaus", (PyCFunction)PyHirschImage_Plateaus, METH_NOARGS, "Plateaus()\n\nDetect all gray value plateaus." },
    {"FindScaledShapeModels", (PyCFunction)PyHirschImage_FindScaledShapeModels, METH_VARARGS, "FindScaledShapeModels(ModelIDs,AngleStart,AngleExtent,ScaleMin,ScaleMax,MinScore,NumMatches,MaxOverlap,SubPixel,NumLevels,Greediness)\n\nFind the best matches of multiple scale invariant shape models." },
    {"GenPsfMotion", (PyCFunction)PyHirschImage_GenPsfMotion, METH_STATIC|METH_VARARGS, "GenPsfMotion(PSFwidth,PSFheight,Blurring,Angle,Type)\n\nGenerate an impulse response of a (linearly) motion blurring." },
    {"SetGrayval", (PyCFunction)PyHirschImage_SetGrayval, METH_VARARGS, "SetGrayval(Row,Column,Grayval)\n\nSet single gray values in an image." },
    {"ReduceDomain", (PyCFunction)PyHirschImage_ReduceDomain, METH_VARARGS, "ReduceDomain(Region)\n\nReduce the domain of an image." },
    {"Get1dBarCodeScanline", (PyCFunction)PyHirschImage_Get1dBarCodeScanline, METH_VARARGS, "Get1dBarCodeScanline(BarCodeDescr,GenericName,GenericValue,Orientation,StopIfFound)\n\nExtract the widths of the elements inside a bar code region." },
    {"GrayDilationShape", (PyCFunction)PyHirschImage_GrayDilationShape, METH_VARARGS, "GrayDilationShape(MaskHeight,MaskWidth,MaskShape)\n\nDetermine the maximum gray value within a selected mask." },
    {"MeanSp", (PyCFunction)PyHirschImage_MeanSp, METH_VARARGS, "MeanSp(MaskWidth,MaskHeight,MinThresh,MaxThresh)\n\nSuppress salt and pepper noise." },
    {"WriteOcrTrainfImage", (PyCFunction)PyHirschImage_WriteOcrTrainfImage, METH_VARARGS, "WriteOcrTrainfImage(Class,FileName)\n\nWrite characters into a training file." },
    {"GrayTophat", (PyCFunction)PyHirschImage_GrayTophat, METH_VARARGS, "GrayTophat(SE)\n\nPerform a gray value top hat transformation on an image." },
    {"GaussImage", (PyCFunction)PyHirschImage_GaussImage, METH_VARARGS, "GaussImage(Size)\n\nSmooth using discrete Gauss functions." },
    {"GenBandfilter", (PyCFunction)PyHirschImage_GenBandfilter, METH_STATIC|METH_VARARGS, "GenBandfilter(MinFrequency,MaxFrequency,Norm,Mode,Width,Height)\n\nGenerate an ideal band filter." },
    {"AppendChannel", (PyCFunction)PyHirschImage_AppendChannel, METH_VARARGS, "AppendChannel(Image)\n\nAppend additional matrices (channels) to the image." },
    {"FindAnisoShapeModels", (PyCFunction)PyHirschImage_FindAnisoShapeModels, METH_VARARGS, "FindAnisoShapeModels(ModelIDs,AngleStart,AngleExtent,ScaleRMin,ScaleRMax,ScaleCMin,ScaleCMax,MinScore,NumMatches,MaxOverlap,SubPixel,NumLevels,Greediness)\n\nFind the best matches of multiple anisotropic scale invariant shape\nmodels." },
    {"GenPsfDefocus", (PyCFunction)PyHirschImage_GenPsfDefocus, METH_STATIC|METH_VARARGS, "GenPsfDefocus(PSFwidth,PSFheight,Blurring)\n\nGenerate an impulse response of an uniform out-of-focus blurring." },
    {"ZoomImageFactor", (PyCFunction)PyHirschImage_ZoomImageFactor, METH_VARARGS, "ZoomImageFactor(ScaleWidth,ScaleHeight,Interpolation)\n\nZoom an image by a given factor." },
    {"ExhaustiveMatch", (PyCFunction)PyHirschImage_ExhaustiveMatch, METH_VARARGS, "ExhaustiveMatch(RegionOfInterest,ImageTemplate,Mode)\n\nMatching of a template and an image." },
    {"WriteImage", (PyCFunction)PyHirschImage_WriteImage, METH_VARARGS, "WriteImage(Format,FillColor,FileName)\n\nWrite images in graphic formats." },
    {"ZeroCrossing", (PyCFunction)PyHirschImage_ZeroCrossing, METH_NOARGS, "ZeroCrossing()\n\nExtrakt zero crossings from an image." },
    {"GrayClosingRect", (PyCFunction)PyHirschImage_GrayClosingRect, METH_VARARGS, "GrayClosingRect(MaskHeight,MaskWidth)\n\nPerform a gray value closing with a rectangular mask." },
    {"AffineTransImageSize", (PyCFunction)PyHirschImage_AffineTransImageSize, METH_VARARGS, "AffineTransImageSize(HomMat2D,Interpolation,Width,Height)\n\nApply an arbitrary affine 2D transformation to an image and specify\nthe output image size." },
    {"GenDiscSe", (PyCFunction)PyHirschImage_GenDiscSe, METH_STATIC|METH_VARARGS, "GenDiscSe(Type,Width,Height,Smax)\n\nGenerate ellipsoidal structuring elements for gray morphology." },
    {"Find2dBarCode", (PyCFunction)PyHirschImage_Find2dBarCode, METH_VARARGS, "Find2dBarCode(BarCodeDescr,GenParamNames,GenParamValues)\n\nFind regions that might contain a 2D bar code." },
    {"LinesFacet", (PyCFunction)PyHirschImage_LinesFacet, METH_VARARGS, "LinesFacet(MaskSize,Low,High,LightDark)\n\nDetection of lines using the facet model." },
    {"Find1dBarCode", (PyCFunction)PyHirschImage_Find1dBarCode, METH_VARARGS, "Find1dBarCode(BarCodeDescr,GenericName,GenericValue)\n\nLook for one bar code in an image." },
    {"FreiDir", (PyCFunction)PyHirschImage_FreiDir, METH_NOARGS, "FreiDir()\n\nDetect edges (amplitude and direction) using the Frei-Chen operator." },
    {"GrayDilationRect", (PyCFunction)PyHirschImage_GrayDilationRect, METH_VARARGS, "GrayDilationRect(MaskHeight,MaskWidth)\n\nDetermine the maximum gray value within a rectangle." },
    {"PixType", (PyCFunction)PyHirschImage_PixType, METH_NOARGS, "PixType()\n\n" },
    {"GrayOpening", (PyCFunction)PyHirschImage_GrayOpening, METH_VARARGS, "GrayOpening(SE)\n\nPerform a gray value opening on an image." },
    {"FindMarksAndPose", (PyCFunction)PyHirschImage_FindMarksAndPose, METH_VARARGS, "FindMarksAndPose(CalTabRegion,CalTabDescrFile,StartCamParam,StartThresh,DeltaThresh,MinThresh,Alpha,MinContLength,MaxDiamMarks)\n\nExtract the 2D calibration marks from the image and\ncalculate initial values for the exterior camera parameters." },
    {"ZoomImageSize", (PyCFunction)PyHirschImage_ZoomImageSize, METH_VARARGS, "ZoomImageSize(Width,Height,Interpolation)\n\nZoom an image to a given size." },
    {"CharThreshold", (PyCFunction)PyHirschImage_CharThreshold, METH_VARARGS, "CharThreshold(HistoRegion,Sigma,Percent)\n\nPerform a threshold segmentation for extracting characters." },
    {"ScaleImageMax", (PyCFunction)PyHirschImage_ScaleImageMax, METH_NOARGS, "ScaleImageMax()\n\nMaximum gray value spreading in the value range \n0 to 255." },
    {"BitRshift", (PyCFunction)PyHirschImage_BitRshift, METH_VARARGS, "BitRshift(Shift)\n\nRight shift of all pixels of the image." },
    {"ExpandLine", (PyCFunction)PyHirschImage_ExpandLine, METH_VARARGS, "ExpandLine(Coordinate,ExpandType,RowColumn,Threshold)\n\nExpand a region starting at a given line." },
    {"PointsSojka", (PyCFunction)PyHirschImage_PointsSojka, METH_VARARGS, "PointsSojka(MaskSize,SigmaW,SigmaD,MinGrad,MinApparentness,MinAngle,Subpix)\n\nFind corners using the Sojka operator." },
    {"GenImageInterleaved", (PyCFunction)PyHirschImage_GenImageInterleaved, METH_STATIC|METH_VARARGS, "GenImageInterleaved(PixelPointer,ColorFormat,OriginalWidth,OriginalHeight,Alignment,Type,ImageWidth,ImageHeight,StartRow,StartColumn,BitsPerChannel,BitShift)\n\nCreate a three-channel image from a pointer to the interleaved pixels." },
    {"InpaintingAniso", (PyCFunction)PyHirschImage_InpaintingAniso, METH_VARARGS, "InpaintingAniso(Region,Mode,Contrast,Theta,Iterations,Rho)\n\nPerform an inpainting by anisotropic diffusion." },
    {"AbsDiffImage", (PyCFunction)PyHirschImage_AbsDiffImage, METH_VARARGS, "AbsDiffImage(Image2,Mult)\n\nCalculate the absolute difference of two images." },
    {"PaintGray", (PyCFunction)PyHirschImage_PaintGray, METH_VARARGS, "PaintGray(ImageDestination)\n\nPaint the gray values of an image into another image." },
    {"DynThreshold", (PyCFunction)PyHirschImage_DynThreshold, METH_VARARGS, "DynThreshold(ThresholdImage,Offset,LightDark)\n\nSegment an image using a local threshold." },
    {"AutoThreshold", (PyCFunction)PyHirschImage_AutoThreshold, METH_VARARGS, "AutoThreshold(Sigma)\n\nSegment an image using thresholds determined from its histogram." },
    {"EstimateNoise", (PyCFunction)PyHirschImage_EstimateNoise, METH_VARARGS, "EstimateNoise(Method,Percent)\n\nEstimate the image noise from a single image." },
    {"Threshold", (PyCFunction)PyHirschImage_Threshold, METH_VARARGS, "Threshold(MinGray,MaxGray)\n\nSegment an image using global threshold." },
    {"GenImageProto", (PyCFunction)PyHirschImage_GenImageProto, METH_VARARGS, "GenImageProto(Grayval)\n\nCreate an image with a specified constant gray value." },
    {"ClassNdimNorm", (PyCFunction)PyHirschImage_ClassNdimNorm, METH_VARARGS, "ClassNdimNorm(Metric,SingleMultiple,Radius,Center)\n\nClassify pixels using hyper-spheres or hyper-cubes." },
    {"SobelAmp", (PyCFunction)PyHirschImage_SobelAmp, METH_VARARGS, "SobelAmp(FilterType,Size)\n\nDetect edges (amplitude) using the Sobel operator." },
    {"SfsModLr", (PyCFunction)PyHirschImage_SfsModLr, METH_VARARGS, "SfsModLr(Slant,Tilt,Albedo,Ambient)\n\nReconstruct a surface from a gray value image." },
    {"PointsHarrisBinomial", (PyCFunction)PyHirschImage_PointsHarrisBinomial, METH_VARARGS, "PointsHarrisBinomial(MaskSizeGrd,MaskSizeSmooth,Alpha,Threshold,Subpix)\n\nDetect points of interest using the binomial approximation of the Harris\noperator." },
    {"InspectShapeModel", (PyCFunction)PyHirschImage_InspectShapeModel, METH_VARARGS, "InspectShapeModel(NumLevels,Contrast)\n\nCreate the representation of a shape model." },
    {"PolarTransImageInv", (PyCFunction)PyHirschImage_PolarTransImageInv, METH_VARARGS, "PolarTransImageInv(Row,Column,AngleStart,AngleEnd,RadiusStart,RadiusEnd,Width,Height,Interpolation)\n\nTransform an image in polar coordinates back to cartesian coordinates" },
    {"InpaintingTexture", (PyCFunction)PyHirschImage_InpaintingTexture, METH_VARARGS, "InpaintingTexture(Region,MaskSize,SearchSize,Anisotropy,PostIteration,Smoothness)\n\nPerform an inpainting by texture propagation." },
    {"DispColor", (PyCFunction)PyHirschImage_DispColor, METH_VARARGS, "DispColor(WindowHandle)\n\nDisplays a color (RGB) image" },
    {"EliminateSp", (PyCFunction)PyHirschImage_EliminateSp, METH_VARARGS, "EliminateSp(MaskWidth,MaskHeight,MinThresh,MaxThresh)\n\nReplace values outside of thresholds with average value." },
    {"LowlandsCenter", (PyCFunction)PyHirschImage_LowlandsCenter, METH_NOARGS, "LowlandsCenter()\n\nDetect the centers of all gray value lowlands." },
    {"BestMatchRotMg", (PyCFunction)PyHirschImage_BestMatchRotMg, METH_VARARGS, "BestMatchRotMg(TemplateID,AngleStart,AngleExtend,MaxError,SubPixel,NumLevels)\n\nSearching the best matching of a template and a pyramid with rotation." },
    {"MinImage", (PyCFunction)PyHirschImage_MinImage, METH_VARARGS, "MinImage(Image2)\n\nCalculate the minimum of two images pixel by pixel." },
    {"CheckDifference", (PyCFunction)PyHirschImage_CheckDifference, METH_VARARGS, "CheckDifference(Pattern,Mode,DiffLowerBound,DiffUpperBound,GrayOffset,AddRow,AddCol)\n\nCompare two images pixel by pixel." },
    {"GenStdBandpass", (PyCFunction)PyHirschImage_GenStdBandpass, METH_STATIC|METH_VARARGS, "GenStdBandpass(Frequency,Sigma,Type,Norm,Mode,Width,Height)\n\nGenerate a bandpass filter with Gaussian or sinusoidal shape." },
    {"Roberts", (PyCFunction)PyHirschImage_Roberts, METH_VARARGS, "Roberts(FilterType)\n\nDetect edges using the Roberts filter." },
    {"MirrorImage", (PyCFunction)PyHirschImage_MirrorImage, METH_VARARGS, "MirrorImage(Mode)\n\nMirror an image." },
    {"ChangeFormat", (PyCFunction)PyHirschImage_ChangeFormat, METH_VARARGS, "ChangeFormat(Width,Height)\n\nChange image size." },
    {"PolarTransImageExt", (PyCFunction)PyHirschImage_PolarTransImageExt, METH_VARARGS, "PolarTransImageExt(Row,Column,AngleStart,AngleEnd,RadiusStart,RadiusEnd,Width,Height,Interpolation)\n\nTransform an annular arc in an image to polar coordinates." },
    {"ReadGraySe", (PyCFunction)PyHirschImage_ReadGraySe, METH_STATIC|METH_VARARGS, "ReadGraySe(FileName)\n\nLoad a structuring element for gray morphology." },
    {"ExpandDomainGray", (PyCFunction)PyHirschImage_ExpandDomainGray, METH_VARARGS, "ExpandDomainGray(ExpansionRange)\n\nExpand the domain of an image and set the gray values in the\nexpanded domain." },
    {"MeanImage", (PyCFunction)PyHirschImage_MeanImage, METH_VARARGS, "MeanImage(MaskWidth,MaskHeight)\n\nSmooth by averaging." },
    {"EquHistoImage", (PyCFunction)PyHirschImage_EquHistoImage, METH_NOARGS, "EquHistoImage()\n\nHistogram linearisation of images" },
    {"EstimateAlAm", (PyCFunction)PyHirschImage_EstimateAlAm, METH_NOARGS, "EstimateAlAm()\n\nEstimate the albedo of a surface and the amount of ambient light." },
    {"MidrangeImage", (PyCFunction)PyHirschImage_MidrangeImage, METH_VARARGS, "MidrangeImage(Mask,Margin)\n\nCalculate the average of maximum and minimum inside any mask." },
    {"Rgb1ToGray", (PyCFunction)PyHirschImage_Rgb1ToGray, METH_NOARGS, "Rgb1ToGray()\n\nTransform an RGB image into a gray scale image." },
    {"BitOr", (PyCFunction)PyHirschImage_BitOr, METH_VARARGS, "BitOr(Image2)\n\nBit-by-bit OR of all pixels of the input images." },
    {"TextureLaws", (PyCFunction)PyHirschImage_TextureLaws, METH_VARARGS, "TextureLaws(FilterTypes,Shift,FilterSize)\n\nFilter an image using a Laws texture filter." },
    {"WienerFilter", (PyCFunction)PyHirschImage_WienerFilter, METH_VARARGS, "WienerFilter(Psf,FilteredImage)\n\nImage restoration by Wiener filtering." },
    {"AddNoiseDistribution", (PyCFunction)PyHirschImage_AddNoiseDistribution, METH_VARARGS, "AddNoiseDistribution(Distribution)\n\nAdd noise to an image." },
    {"PowerByte", (PyCFunction)PyHirschImage_PowerByte, METH_NOARGS, "PowerByte()\n\nReturn the power spectrum of a complex image." },
    {"BinocularDisparityMg", (PyCFunction)PyHirschImage_BinocularDisparityMg, METH_VARARGS, "BinocularDisparityMg(Image2,GrayConstancy,GradientConstancy,Smoothness,InitialGuess,CalculateScore,MGParamName,MGParamValue)\n\nCompute the disparities of a rectified image pair using multigrid\nmethods." },
    {"DivImage", (PyCFunction)PyHirschImage_DivImage, METH_VARARGS, "DivImage(Image2,Mult,Add)\n\nDivide two images." },
    {"FftImageInv", (PyCFunction)PyHirschImage_FftImageInv, METH_NOARGS, "FftImageInv()\n\nCompute the inverse fast Fourier transform of an image." },
    {"DispImage", (PyCFunction)PyHirschImage_DispImage, METH_VARARGS, "DispImage(WindowHandle)\n\nDisplays gray value images." },
    {"LinesGauss", (PyCFunction)PyHirschImage_LinesGauss, METH_VARARGS, "LinesGauss(Sigma,Low,High,LightDark,ExtractWidth,CorrectPositions,CompleteJunctions)\n\nDetect lines and their width." },
    {"GrayClosing", (PyCFunction)PyHirschImage_GrayClosing, METH_VARARGS, "GrayClosing(SE)\n\nPerform a gray value closing on an image." },
    {"InstClassName", (PyCFunction)PyHirschImage_InstClassName, METH_NOARGS, "InstClassName()\n\n" },
    {"GenGridRectificationMap", (PyCFunction)PyHirschImage_GenGridRectificationMap, METH_VARARGS, "GenGridRectificationMap(ConnectingLines,GridSpacing,Rotation,Row,Col)\n\nCompute the mapping between the distorted image and the rectified image\nbased upon the points of a regular grid." },
    {"BinocularDisparity", (PyCFunction)PyHirschImage_BinocularDisparity, METH_VARARGS, "BinocularDisparity(Image2,Method,MaskWidth,MaskHeight,TextureThresh,MinDisparity,MaxDisparity,NumLevels,ScoreThresh,Filter,SubDisparity)\n\nCompute the disparities of a rectified image pair using correlation\ntechniques." },
    {"BitXor", (PyCFunction)PyHirschImage_BitXor, METH_VARARGS, "BitXor(Image2)\n\nBit-by-bit XOR of all pixels of the input images." },
    {"NonmaxSuppressionDir", (PyCFunction)PyHirschImage_NonmaxSuppressionDir, METH_VARARGS, "NonmaxSuppressionDir(ImgDir,Mode)\n\nSuppress non-maximum points on an edge using a direction image." },
    {"ConvolImage", (PyCFunction)PyHirschImage_ConvolImage, METH_VARARGS, "ConvolImage(FilterMask,Margin)\n\nConvolve an image with an arbitrary filter mask." },
    {"Shared", (PyCFunction)PyHirschImage_Shared, METH_NOARGS, "Shared()\n\n" },
    {"Class2dimSup", (PyCFunction)PyHirschImage_Class2dimSup, METH_VARARGS, "Class2dimSup(ImageRow,FeatureSpace)\n\nSegment an image using two-dimensional pixel classification." },
    {"EntropyImage", (PyCFunction)PyHirschImage_EntropyImage, METH_VARARGS, "EntropyImage(Width,Height)\n\nCalculate the entropy of gray values within a rectangular window." },
    {"AddImage", (PyCFunction)PyHirschImage_AddImage, METH_VARARGS, "AddImage(Image2,Mult,Add)\n\nAdd two images." },
    {"GenImageGrayRamp", (PyCFunction)PyHirschImage_GenImageGrayRamp, METH_STATIC|METH_VARARGS, "GenImageGrayRamp(Alpha,Beta,Mean,Row,Column,Width,Height)\n\nCreate a gray value ramp." },
    {"WatershedsThreshold", (PyCFunction)PyHirschImage_WatershedsThreshold, METH_VARARGS, "WatershedsThreshold(Threshold)\n\nExtract watershed basins from an image using a threshold." },
    {"FindCaltab", (PyCFunction)PyHirschImage_FindCaltab, METH_VARARGS, "FindCaltab(CalTabDescrFile,SizeGauss,MarkThresh,MinDiamMarks)\n\nSegment the standard calibration plate region in the image." },
    {"GenPrincipalCompTrans", (PyCFunction)PyHirschImage_GenPrincipalCompTrans, METH_NOARGS, "GenPrincipalCompTrans()\n\nCompute the transformation matrix of the principal component\nanalysis of multichannel images." },
    {"GenFilterMask", (PyCFunction)PyHirschImage_GenFilterMask, METH_STATIC|METH_VARARGS, "GenFilterMask(FilterMask,Scale,Width,Height)\n\nStore a filter mask in the spatial domain as a real-image." },
    {"CheckMyObjClass", (PyCFunction)PyHirschImage_CheckMyObjClass, METH_NOARGS, "CheckMyObjClass()\n\n" },
    {"BestMatchRot", (PyCFunction)PyHirschImage_BestMatchRot, METH_VARARGS, "BestMatchRot(TemplateID,AngleStart,AngleExtend,MaxError,SubPixel)\n\nSearching the best matching of a template and an image with rotation." },
    {"RftGeneric", (PyCFunction)PyHirschImage_RftGeneric, METH_VARARGS, "RftGeneric(Direction,Norm,ResultType,Width)\n\nCompute the real-valued fast Fourier transform of an image." },
    {"GrayClosingShape", (PyCFunction)PyHirschImage_GrayClosingShape, METH_VARARGS, "GrayClosingShape(MaskHeight,MaskWidth,MaskShape)\n\nPerform a grayvalue closing with a selected mask." },
    {"GenHighpass", (PyCFunction)PyHirschImage_GenHighpass, METH_STATIC|METH_VARARGS, "GenHighpass(Frequency,Norm,Mode,Width,Height)\n\nGenerate an ideal highpass filter." },
    {"CoocFeatureMatrix", (PyCFunction)PyHirschImage_CoocFeatureMatrix, METH_NOARGS, "CoocFeatureMatrix()\n\nCalculate gray value features from a co-occurrence matrix." },
    {"PrewittDir", (PyCFunction)PyHirschImage_PrewittDir, METH_NOARGS, "PrewittDir()\n\nDetect edges (amplitude and direction) using the Prewitt operator." },
    {"BitSlice", (PyCFunction)PyHirschImage_BitSlice, METH_VARARGS, "BitSlice(Bit)\n\nExtract a bit from the pixels." },
    {"AnisotropicDiffusion", (PyCFunction)PyHirschImage_AnisotropicDiffusion, METH_VARARGS, "AnisotropicDiffusion(Mode,Contrast,Theta,Iterations)\n\nPerform an anisotropic diffusion of an image." },
    {"GenBinocularRectificationMap", (PyCFunction)PyHirschImage_GenBinocularRectificationMap, METH_STATIC|METH_VARARGS, "GenBinocularRectificationMap(CamParam1,CamParam2,RelPose,SubSampling,Method,Interpolation)\n\nGenerate transformation maps that describe the mapping of the images of a \nbinocular camera pair to a common rectified image plane." },
    {"ReadImage", (PyCFunction)PyHirschImage_ReadImage, METH_STATIC|METH_VARARGS, "ReadImage(FileName)\n\nRead an image with different file formats." },
    {"MatchRelPoseRansac", (PyCFunction)PyHirschImage_MatchRelPoseRansac, METH_VARARGS, "MatchRelPoseRansac(Image2,Rows1,Cols1,Rows2,Cols2,CamPar1,CamPar2,GrayMatchMethod,MaskSize,RowMove,ColMove,RowTolerance,ColTolerance,Rotation,MatchThreshold,EstimationMethod,DistanceThreshold,RandSeed)\n\nCompute the relative orientation between two cameras by automatically \nfinding correspondences between image points." },
    {"ReadSequence", (PyCFunction)PyHirschImage_ReadSequence, METH_STATIC|METH_VARARGS, "ReadSequence(HeaderSize,SourceWidth,SourceHeight,StartRow,StartColumn,DestWidth,DestHeight,PixelType,BitOrder,ByteOrder,Pad,Index,FileName)\n\nRead images." },
    {"KirschDir", (PyCFunction)PyHirschImage_KirschDir, METH_NOARGS, "KirschDir()\n\nDetect edges (amplitude and direction) using the Kirsch operator." },
    {"LocalMinSubPix", (PyCFunction)PyHirschImage_LocalMinSubPix, METH_VARARGS, "LocalMinSubPix(Filter,Sigma,Threshold)\n\nSubpixel precise detection of local minima in an image." },
    {"Decompose5", (PyCFunction)PyHirschImage_Decompose5, METH_NOARGS, "Decompose5()\n\nConvert a five-channel image into five images." },
    {"GrayInside", (PyCFunction)PyHirschImage_GrayInside, METH_NOARGS, "GrayInside()\n\nCalculate the lowest possible gray value on an arbitrary path to the\nimage border for each point in the image." },
    {"RegiongrowingN", (PyCFunction)PyHirschImage_RegiongrowingN, METH_VARARGS, "RegiongrowingN(Metric,MinTolerance,MaxTolerance,MinSize)\n\nSegment an image using regiongrowing for multi-channel images." },
    {"Illuminate", (PyCFunction)PyHirschImage_Illuminate, METH_VARARGS, "Illuminate(MaskWidth,MaskHeight,Factor)\n\nIlluminate image." },
    {"Decompose3", (PyCFunction)PyHirschImage_Decompose3, METH_NOARGS, "Decompose3()\n\nConvert a three-channel image into three images." },
    {"Watersheds", (PyCFunction)PyHirschImage_Watersheds, METH_NOARGS, "Watersheds()\n\nExtract watersheds and basins from an image." },
    {"FindShapeModels", (PyCFunction)PyHirschImage_FindShapeModels, METH_VARARGS, "FindShapeModels(ModelIDs,AngleStart,AngleExtent,MinScore,NumMatches,MaxOverlap,SubPixel,NumLevels,Greediness)\n\nFind the best matches of multiple shape models." },
    {"RankN", (PyCFunction)PyHirschImage_RankN, METH_VARARGS, "RankN(RankIndex)\n\nReturn gray values with given rank from multiple channels." },
    {"Decompose7", (PyCFunction)PyHirschImage_Decompose7, METH_NOARGS, "Decompose7()\n\nConvert a seven-channel image into seven images." },
    {"Decompose6", (PyCFunction)PyHirschImage_Decompose6, METH_NOARGS, "Decompose6()\n\nConvert a six-channel image into six images." },
    {"SigmaImage", (PyCFunction)PyHirschImage_SigmaImage, METH_VARARGS, "SigmaImage(MaskHeight,MaskWidth,Sigma)\n\nNon-linear smoothing with the sigma filter." },
    {"Decompose4", (PyCFunction)PyHirschImage_Decompose4, METH_NOARGS, "Decompose4()\n\nConvert a four-channel image into four images." },
    {"CornerResponse", (PyCFunction)PyHirschImage_CornerResponse, METH_VARARGS, "CornerResponse(Size,Weight)\n\nSearching corners in images." },
    {"Decompose2", (PyCFunction)PyHirschImage_Decompose2, METH_NOARGS, "Decompose2()\n\nConvert a two-channel image into two images." },