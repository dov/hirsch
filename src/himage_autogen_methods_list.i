    {"Pouring", (PyCFunction)PyHirschImage_Pouring, METH_VARARGS, "Pouring(Mode,MinGray,MaxGray)\n\nSegment an image by \"pouring water\" over it." },
    {"VectorFieldLength", (PyCFunction)PyHirschImage_VectorFieldLength, METH_VARARGS, "VectorFieldLength(Mode)\n\nCompute the length of the vectors of a vector field." },
    {"SelectGrayvaluesFromChannels", (PyCFunction)PyHirschImage_SelectGrayvaluesFromChannels, METH_VARARGS, "SelectGrayvaluesFromChannels(IndexImage)\n\nSelection of gray values of a multi-channel image using an index image." },
    {"MapImage", (PyCFunction)PyHirschImage_MapImage, METH_VARARGS, "MapImage(Map)\n\nApply a general transformation to an image." },
    {"GaussFilter", (PyCFunction)PyHirschImage_GaussFilter, METH_VARARGS, "GaussFilter(Size)\n\nSmooth using discrete gauss functions." },
    {"ProjMatchPointsRansac", (PyCFunction)PyHirschImage_ProjMatchPointsRansac, METH_VARARGS, "ProjMatchPointsRansac(Image2,Rows1,Cols1,Rows2,Cols2,GrayMatchMethod,MaskSize,RowMove,ColMove,RowTolerance,ColTolerance,Rotation,MatchThreshold,EstimationMethod,DistanceThreshold,RandSeed)\n\nCompute a projective transformation matrix between two images by finding correspondences between points." },
    {"MeanN", (PyCFunction)PyHirschImage_MeanN, METH_NOARGS, "MeanN()\n\nAverage gray values over several channels." },
    {"EnergyGabor", (PyCFunction)PyHirschImage_EnergyGabor, METH_VARARGS, "EnergyGabor(ImageHilbert)\n\nCalculate the energy of a two-channel image." },
    {"EstimateTiltLr", (PyCFunction)PyHirschImage_EstimateTiltLr, METH_NOARGS, "EstimateTiltLr()\n\nEstimate the tilt of a light source." },
    {"FuzzyPerimeter", (PyCFunction)PyHirschImage_FuzzyPerimeter, METH_VARARGS, "FuzzyPerimeter(Regions,Apar,Cpar)\n\nCalculate the fuzzy perimeter of a region." },
    {"GrayHistoRange", (PyCFunction)PyHirschImage_GrayHistoRange, METH_VARARGS, "GrayHistoRange(Regions,Min,Max,NumBins)\n\nCalculate the gray value distribution of a single channel image within a certain gray value range." },
    {"Compose4", (PyCFunction)PyHirschImage_Compose4, METH_VARARGS, "Compose4(Image2,Image3,Image4)\n\nConvert 4 images into a four-channel image." },
    {"Compose5", (PyCFunction)PyHirschImage_Compose5, METH_VARARGS, "Compose5(Image2,Image3,Image4,Image5)\n\nConvert 5 images into a five-channel image." },
    {"Compose6", (PyCFunction)PyHirschImage_Compose6, METH_VARARGS, "Compose6(Image2,Image3,Image4,Image5,Image6)\n\nConvert 6 images into a six-channel image." },
    {"Compose7", (PyCFunction)PyHirschImage_Compose7, METH_VARARGS, "Compose7(Image2,Image3,Image4,Image5,Image6,Image7)\n\nConvert 7 images into a seven-channel image." },
    {"Compose2", (PyCFunction)PyHirschImage_Compose2, METH_VARARGS, "Compose2(Image2)\n\nConvert two images into a two-channel image." },
    {"Compose3", (PyCFunction)PyHirschImage_Compose3, METH_VARARGS, "Compose3(Image2,Image3)\n\nConvert 3 images into a three-channel image." },
    {"TransToRgb", (PyCFunction)PyHirschImage_TransToRgb, METH_VARARGS, "TransToRgb(ImageInput2,ImageInput3,ColorSpace)\n\nTransform an image from an arbitrary color space to the RGB color space." },
    {"TopographicSketch", (PyCFunction)PyHirschImage_TopographicSketch, METH_NOARGS, "TopographicSketch()\n\nCompute the topographic primal sketch of an image." },
    {"MeanCurvatureFlow", (PyCFunction)PyHirschImage_MeanCurvatureFlow, METH_VARARGS, "MeanCurvatureFlow(Sigma,Theta,Iterations)\n\nApply the mean curvature flow to an image." },
    {"GraySkeleton", (PyCFunction)PyHirschImage_GraySkeleton, METH_NOARGS, "GraySkeleton()\n\nThinning of gray value images." },
    {"KirschAmp", (PyCFunction)PyHirschImage_KirschAmp, METH_NOARGS, "KirschAmp()\n\nDetect edges (amplitude) using the Kirsch operator." },
    {"GetGrayvalContourXld", (PyCFunction)PyHirschImage_GetGrayvalContourXld, METH_VARARGS, "GetGrayvalContourXld(Contour,Interpolation)\n\nReturn gray values of an image at the positions of an XLD contour." },
    {"FillInterlace", (PyCFunction)PyHirschImage_FillInterlace, METH_VARARGS, "FillInterlace(Mode)\n\nInterpolate 2 video half images." },
    {"BitAnd", (PyCFunction)PyHirschImage_BitAnd, METH_VARARGS, "BitAnd(Image2)\n\nBit-by-bit AND of all pixels of the input images." },
    {"BandpassImage", (PyCFunction)PyHirschImage_BandpassImage, METH_VARARGS, "BandpassImage(FilterType)\n\nEdge extraction using bandpass filters." },
    {"CreateTemplate", (PyCFunction)PyHirschImage_CreateTemplate, METH_VARARGS, "CreateTemplate(FirstError,NumLevel,Optimize,GrayValues)\n\nPreparing a pattern for template matching." },
    {"SubImage", (PyCFunction)PyHirschImage_SubImage, METH_VARARGS, "SubImage(ImageSubtrahend,Mult,Add)\n\nSubtract two images." },
    {"ScaleImage", (PyCFunction)PyHirschImage_ScaleImage, METH_VARARGS, "ScaleImage(Mult,Add)\n\nScale the gray values of an image." },
    {"BilateralFilter", (PyCFunction)PyHirschImage_BilateralFilter, METH_VARARGS, "BilateralFilter(ImageJoint,SigmaSpatial,SigmaRange,GenParamName,GenParamValue)\n\nbilateral filtering of an image." },
    {"DecodeBarCodeRectangle2", (PyCFunction)PyHirschImage_DecodeBarCodeRectangle2, METH_VARARGS, "DecodeBarCodeRectangle2(BarCodeHandle,CodeType,Row,Column,Phi,Length1,Length2)\n\nDecode bar code symbols within a rectangle." },
    {"Lowlands", (PyCFunction)PyHirschImage_Lowlands, METH_NOARGS, "Lowlands()\n\nDetect all gray value lowlands." },
    {"GetDomain", (PyCFunction)PyHirschImage_GetDomain, METH_NOARGS, "GetDomain()\n\nGet the domain of an image." },
    {"RealToVectorField", (PyCFunction)PyHirschImage_RealToVectorField, METH_VARARGS, "RealToVectorField(Col,Type)\n\nConvert two real-valued images into a vector field image." },
    {"GetImagePointer3", (PyCFunction)PyHirschImage_GetImagePointer3, METH_NOARGS, "GetImagePointer3()\n\nAccess the pointers of a colored image." },
    {"PowerLn", (PyCFunction)PyHirschImage_PowerLn, METH_NOARGS, "PowerLn()\n\nReturn the power spectrum of a complex image." },
    {"GetImagePointer1", (PyCFunction)PyHirschImage_GetImagePointer1, METH_NOARGS, "GetImagePointer1()\n\nAccess the pointer of a channel." },
    {"Histo2dim", (PyCFunction)PyHirschImage_Histo2dim, METH_VARARGS, "Histo2dim(Regions,ImageRow)\n\nCalculate the histogram of two-channel gray value images." },
    {"SimulateMotion", (PyCFunction)PyHirschImage_SimulateMotion, METH_VARARGS, "SimulateMotion(Blurring,Angle,Type)\n\nSimulation of (linearly) motion blur." },
    {"CropDomainRel", (PyCFunction)PyHirschImage_CropDomainRel, METH_VARARGS, "CropDomainRel(Top,Left,Bottom,Right)\n\nCut out an image area relative to the domain." },
    {"CriticalPointsSubPix", (PyCFunction)PyHirschImage_CriticalPointsSubPix, METH_VARARGS, "CriticalPointsSubPix(Filter,Sigma,Threshold)\n\nSubpixel precise detection of critical points in an image." },
    {"CreateTemplateRot", (PyCFunction)PyHirschImage_CreateTemplateRot, METH_VARARGS, "CreateTemplateRot(NumLevel,AngleStart,AngleExtend,AngleStep,Optimize,GrayValues)\n\nPreparing a pattern for template matching with rotation." },
    {"CropPart", (PyCFunction)PyHirschImage_CropPart, METH_VARARGS, "CropPart(Row,Column,Width,Height)\n\nCut out one or more rectangular image areas." },
    {"PaintXld", (PyCFunction)PyHirschImage_PaintXld, METH_VARARGS, "PaintXld(XLD,Grayval)\n\nPaint XLD objects into an image." },
    {"GenDerivativeFilter", (PyCFunction)PyHirschImage_GenDerivativeFilter, METH_VARARGS, "GenDerivativeFilter(Derivative,Exponent,Norm,Mode,Width,Height)\n\nGenerate a derivative filter in the frequency domain." },
    {"GrayRangeRect", (PyCFunction)PyHirschImage_GrayRangeRect, METH_VARARGS, "GrayRangeRect(MaskHeight,MaskWidth)\n\nDetermine the gray value range within a rectangle." },
    {"SaddlePointsSubPix", (PyCFunction)PyHirschImage_SaddlePointsSubPix, METH_VARARGS, "SaddlePointsSubPix(Filter,Sigma,Threshold)\n\nSubpixel precise detection of saddle points in an image." },
    {"FindBarCode", (PyCFunction)PyHirschImage_FindBarCode, METH_VARARGS, "FindBarCode(BarCodeHandle,CodeType)\n\nDetect and read bar code symbols in an image." },
    {"AdaptTemplate", (PyCFunction)PyHirschImage_AdaptTemplate, METH_VARARGS, "AdaptTemplate(TemplateID)\n\nAdapting a template to the size of an image." },
    {"HysteresisThreshold", (PyCFunction)PyHirschImage_HysteresisThreshold, METH_VARARGS, "HysteresisThreshold(Low,High,MaxLength)\n\nPerform a hysteresis threshold operation on an image." },
    {"PhaseDeg", (PyCFunction)PyHirschImage_PhaseDeg, METH_NOARGS, "PhaseDeg()\n\nReturn the phase of a complex image in degrees." },
    {"CropDomain", (PyCFunction)PyHirschImage_CropDomain, METH_NOARGS, "CropDomain()\n\nCut out of defined gray values." },
    {"ThresholdSubPix", (PyCFunction)PyHirschImage_ThresholdSubPix, METH_VARARGS, "ThresholdSubPix(Threshold)\n\nExtract level crossings from an image with subpixel accuracy." },
    {"PowerReal", (PyCFunction)PyHirschImage_PowerReal, METH_NOARGS, "PowerReal()\n\nReturn the power spectrum of a complex image." },
    {"PhotometricStereo", (PyCFunction)PyHirschImage_PhotometricStereo, METH_VARARGS, "PhotometricStereo(Slants,Tilts,ResultType,ReconstructionMethod,GenParamName,GenParamValue)\n\nReconstruct a surface according to the photometric stereo technique." },
    {"DualThreshold", (PyCFunction)PyHirschImage_DualThreshold, METH_VARARGS, "DualThreshold(MinSize,MinGray,Threshold)\n\nThreshold operator for signed images." },
    {"GenBandpass", (PyCFunction)PyHirschImage_GenBandpass, METH_VARARGS, "GenBandpass(MinFrequency,MaxFrequency,Norm,Mode,Width,Height)\n\nGenerate an ideal bandpass filter." },
    {"FftImage", (PyCFunction)PyHirschImage_FftImage, METH_NOARGS, "FftImage()\n\nCompute the fast Fourier transform of an image." },
    {"PlaneDeviation", (PyCFunction)PyHirschImage_PlaneDeviation, METH_VARARGS, "PlaneDeviation(Regions)\n\nCalculate the deviation of the gray values from the approximating image plane." },
    {"DetermineShapeModelParams", (PyCFunction)PyHirschImage_DetermineShapeModelParams, METH_VARARGS, "DetermineShapeModelParams(NumLevels,AngleStart,AngleExtent,ScaleMin,ScaleMax,Optimization,Metric,Contrast,MinContrast,Parameters)\n\nDetermine the parameters of a shape model." },
    {"ShockFilter", (PyCFunction)PyHirschImage_ShockFilter, METH_VARARGS, "ShockFilter(Theta,Iterations,Mode,Sigma)\n\nApply a shock filter to an image." },
    {"DotsImage", (PyCFunction)PyHirschImage_DotsImage, METH_VARARGS, "DotsImage(Diameter,FilterType,PixelShift)\n\nEnhance circular dots in an image." },
    {"FullDomain", (PyCFunction)PyHirschImage_FullDomain, METH_NOARGS, "FullDomain()\n\nExpand the domain of an image to maximum." },
    {"DerivateGauss", (PyCFunction)PyHirschImage_DerivateGauss, METH_VARARGS, "DerivateGauss(Sigma,Component)\n\nConvolve an image with derivatives of the Gaussian." },
    {"GetGrayval", (PyCFunction)PyHirschImage_GetGrayval, METH_VARARGS, "GetGrayval(Row,Column)\n\nAccess the gray values of an image object." },
    {"FastMatchMg", (PyCFunction)PyHirschImage_FastMatchMg, METH_VARARGS, "FastMatchMg(TemplateID,MaxError,NumLevel)\n\nSearching all good grayvalue matches in a pyramid." },
    {"DeviationImage", (PyCFunction)PyHirschImage_DeviationImage, METH_VARARGS, "DeviationImage(Width,Height)\n\nCalculate the standard deviation of gray values within rectangular windows." },
    {"NonmaxSuppressionAmp", (PyCFunction)PyHirschImage_NonmaxSuppressionAmp, METH_VARARGS, "NonmaxSuppressionAmp(Mode)\n\nSuppress non-maximum points on an edge." },
    {"AcosImage", (PyCFunction)PyHirschImage_AcosImage, METH_NOARGS, "AcosImage()\n\nCalculate the arccosine of an image." },
    {"ZeroCrossingSubPix", (PyCFunction)PyHirschImage_ZeroCrossingSubPix, METH_NOARGS, "ZeroCrossingSubPix()\n\nExtract zero crossings from an image with subpixel accuracy." },
    {"GenMeanFilter", (PyCFunction)PyHirschImage_GenMeanFilter, METH_VARARGS, "GenMeanFilter(MaskShape,Diameter1,Diameter2,Phi,Norm,Mode,Width,Height)\n\nGenerate a mean filter in the frequency domain." },
    {"HarmonicInterpolation", (PyCFunction)PyHirschImage_HarmonicInterpolation, METH_VARARGS, "HarmonicInterpolation(Region,Precision)\n\nPerform a harmonic interpolation on an image region." },
    {"BestMatchRot", (PyCFunction)PyHirschImage_BestMatchRot, METH_VARARGS, "BestMatchRot(TemplateID,AngleStart,AngleExtend,MaxError,SubPixel)\n\nSearching the best matching of a template and an image with rotation." },
    {"BinThreshold", (PyCFunction)PyHirschImage_BinThreshold, METH_NOARGS, "BinThreshold()\n\nSegment an image using an automatically determined threshold." },
    {"ProjectiveTransImage", (PyCFunction)PyHirschImage_ProjectiveTransImage, METH_VARARGS, "ProjectiveTransImage(HomMat2D,Interpolation,AdaptImageSize,TransformDomain)\n\nApply a projective transformation to an image." },
    {"RobinsonDir", (PyCFunction)PyHirschImage_RobinsonDir, METH_NOARGS, "RobinsonDir()\n\nDetect edges (amplitude and direction) using the Robinson operator." },
    {"Laplace", (PyCFunction)PyHirschImage_Laplace, METH_VARARGS, "Laplace(ResultType,MaskSize,FilterMask)\n\nCalculate the Laplace operator by using finite differences." },
    {"HoughLinesDir", (PyCFunction)PyHirschImage_HoughLinesDir, METH_VARARGS, "HoughLinesDir(DirectionUncertainty,AngleResolution,Smoothing,FilterSize,Threshold,AngleGap,DistGap,GenLines)\n\nDetect lines in edge images with the help of the Hough transform using local gradient direction and return them in normal form." },
    {"AffineTransImage", (PyCFunction)PyHirschImage_AffineTransImage, METH_VARARGS, "AffineTransImage(HomMat2D,Interpolation,AdaptImageSize)\n\nApply an arbitrary affine 2D transformation to images." },
    {"Height", (PyCFunction)PyHirschImage_Height, METH_NOARGS, "Height()\n\nThe center row of the region" },
    {"BitMask", (PyCFunction)PyHirschImage_BitMask, METH_VARARGS, "BitMask(BitMask)\n\nLogical \"AND\" of each pixel using a bit mask." },
    {"PointsSojka", (PyCFunction)PyHirschImage_PointsSojka, METH_VARARGS, "PointsSojka(MaskSize,SigmaW,SigmaD,MinGrad,MinApparentness,MinAngle,Subpix)\n\nFind corners using the Sojka operator." },
    {"VectorFieldToReal", (PyCFunction)PyHirschImage_VectorFieldToReal, METH_NOARGS, "VectorFieldToReal()\n\nConvert a vector field image into two real-valued images." },
    {"LutTrans", (PyCFunction)PyHirschImage_LutTrans, METH_VARARGS, "LutTrans(Lut)\n\nTransform an image with a gray-value look-up-table" },
    {"TransFromRgb", (PyCFunction)PyHirschImage_TransFromRgb, METH_VARARGS, "TransFromRgb(ImageGreen,ImageBlue,ColorSpace)\n\nTransform an image from the RGB color space to an arbitrary color space." },
    {"DualRank", (PyCFunction)PyHirschImage_DualRank, METH_VARARGS, "DualRank(MaskType,Radius,ModePercent,Margin)\n\nOpening, Median and Closing with circle or rectangle mask." },
    {"CoocFeatureImage", (PyCFunction)PyHirschImage_CoocFeatureImage, METH_VARARGS, "CoocFeatureImage(Regions,LdGray,Direction)\n\nCalculate a co-occurrence matrix and derive gray value features thereof." },
    {"EstimateSlAlLr", (PyCFunction)PyHirschImage_EstimateSlAlLr, METH_NOARGS, "EstimateSlAlLr()\n\nEstimate the slant of a light source and the albedo of a surface." },
    {"EdgesImage", (PyCFunction)PyHirschImage_EdgesImage, METH_VARARGS, "EdgesImage(Filter,Alpha,NMS,Low,High)\n\nExtract edges using Deriche, Lanser, Shen, or Canny filters." },
    {"CopyImage", (PyCFunction)PyHirschImage_CopyImage, METH_NOARGS, "CopyImage()\n\nCopy an image and allocate new memory for it." },
    {"CosImage", (PyCFunction)PyHirschImage_CosImage, METH_NOARGS, "CosImage()\n\nCalculate the cosine of an image." },
    {"ProjMatchPointsDistortionRansacGuided", (PyCFunction)PyHirschImage_ProjMatchPointsDistortionRansacGuided, METH_VARARGS, "ProjMatchPointsDistortionRansacGuided(Image2,Rows1,Cols1,Rows2,Cols2,GrayMatchMethod,MaskSize,HomMat2DGuide,KappaGuide,DistanceTolerance,MatchThreshold,EstimationMethod,DistanceThreshold,RandSeed)\n\nCompute a projective transformation matrix and the radial distortion coefficient between two images by finding correspondences between points based on known approximations of the projective transformation matrix and the radial distortion coefficient." },
    {"RankImage", (PyCFunction)PyHirschImage_RankImage, METH_VARARGS, "RankImage(Mask,Rank,Margin)\n\nCompute a rank filter with arbitrary masks." },
    {"PointsFoerstner", (PyCFunction)PyHirschImage_PointsFoerstner, METH_VARARGS, "PointsFoerstner(SigmaGrad,SigmaInt,SigmaPoints,ThreshInhom,ThreshShape,Smoothing,EliminateDoublets)\n\nDetect points of interest using the Foerstner operator." },
    {"GrayDilation", (PyCFunction)PyHirschImage_GrayDilation, METH_VARARGS, "GrayDilation(SE)\n\nPerform a gray value dilation on an image." },
    {"GenSinBandpass", (PyCFunction)PyHirschImage_GenSinBandpass, METH_VARARGS, "GenSinBandpass(Frequency,Norm,Mode,Width,Height)\n\nGenerate a bandpass filter with sinusoidal shape." },
    {"MatchFundamentalMatrixRansac", (PyCFunction)PyHirschImage_MatchFundamentalMatrixRansac, METH_VARARGS, "MatchFundamentalMatrixRansac(Image2,Rows1,Cols1,Rows2,Cols2,GrayMatchMethod,MaskSize,RowMove,ColMove,RowTolerance,ColTolerance,Rotation,MatchThreshold,EstimationMethod,DistanceThreshold,RandSeed)\n\nCompute the fundamental matrix for a pair of stereo images by automatically finding correspondences between image points." },
    {"ShadeHeightField", (PyCFunction)PyHirschImage_ShadeHeightField, METH_VARARGS, "ShadeHeightField(Slant,Tilt,Albedo,Ambient,Shadows)\n\nShade a height field." },
    {"BestMatchMg", (PyCFunction)PyHirschImage_BestMatchMg, METH_VARARGS, "BestMatchMg(TemplateID,MaxError,SubPixel,NumLevels,WhichLevels)\n\nSearching the best grayvalue matches in a pyramid." },
    {"FastMatch", (PyCFunction)PyHirschImage_FastMatch, METH_VARARGS, "FastMatch(TemplateID,MaxError)\n\nSearching all good matches of a template and an image." },
    {"SobelDir", (PyCFunction)PyHirschImage_SobelDir, METH_VARARGS, "SobelDir(FilterType,Size)\n\nDetect edges (amplitude and direction) using the Sobel operator." },
    {"ProjectiveTransImageSize", (PyCFunction)PyHirschImage_ProjectiveTransImageSize, METH_VARARGS, "ProjectiveTransImageSize(HomMat2D,Interpolation,Width,Height,TransformDomain)\n\nApply a projective transformation to an image and specify the output image size." },
    {"GrayOpeningShape", (PyCFunction)PyHirschImage_GrayOpeningShape, METH_VARARGS, "GrayOpeningShape(MaskHeight,MaskWidth,MaskShape)\n\nPerform a gray value opening with a selected mask." },
    {"ConvertImageType", (PyCFunction)PyHirschImage_ConvertImageType, METH_VARARGS, "ConvertImageType(NewType)\n\nConvert the type of an image." },
    {"FindRectificationGrid", (PyCFunction)PyHirschImage_FindRectificationGrid, METH_VARARGS, "FindRectificationGrid(MinContrast,Radius)\n\nSegment the rectification grid region in the image." },
    {"DetectEdgeSegments", (PyCFunction)PyHirschImage_DetectEdgeSegments, METH_VARARGS, "DetectEdgeSegments(SobelSize,MinAmplitude,MaxDistance,MinLength)\n\nDetect straight edge segments." },
    {"GenCubeMapMosaic", (PyCFunction)PyHirschImage_GenCubeMapMosaic, METH_VARARGS, "GenCubeMapMosaic(CameraMatrices,RotationMatrices,CubeMapDimension,StackingOrder,Interpolation)\n\nCreate 6 cube map images of a spherical mosaic." },
    {"LocalMaxSubPix", (PyCFunction)PyHirschImage_LocalMaxSubPix, METH_VARARGS, "LocalMaxSubPix(Filter,Sigma,Threshold)\n\nSubpixel precise detection of local maxima in an image." },
    {"LocalThreshold", (PyCFunction)PyHirschImage_LocalThreshold, METH_VARARGS, "LocalThreshold(Method,LightDark,GenParamName,GenParamValue)\n\nSegment an image using local thresholding." },
    {"EdgesColor", (PyCFunction)PyHirschImage_EdgesColor, METH_VARARGS, "EdgesColor(Filter,Alpha,NMS,Low,High)\n\nExtract color edges using Canny, Deriche, or Shen filters." },
    {"LabelToRegion", (PyCFunction)PyHirschImage_LabelToRegion, METH_NOARGS, "LabelToRegion()\n\nExtract regions with equal gray values from an image." },
    {"ConvolGabor", (PyCFunction)PyHirschImage_ConvolGabor, METH_VARARGS, "ConvolGabor(GaborFilter)\n\nConvolve an image with a Gabor filter in the frequency domain." },
    {"OverpaintRegion", (PyCFunction)PyHirschImage_OverpaintRegion, METH_VARARGS, "OverpaintRegion(Region,Grayval,Type)\n\nOverpaint regions in an image." },
    {"GrayErosionShape", (PyCFunction)PyHirschImage_GrayErosionShape, METH_VARARGS, "GrayErosionShape(MaskHeight,MaskWidth,MaskShape)\n\nDetermine the minimum gray value within a selected mask." },
    {"InvertImage", (PyCFunction)PyHirschImage_InvertImage, METH_NOARGS, "InvertImage()\n\nInvert an image." },
    {"Regiongrowing", (PyCFunction)PyHirschImage_Regiongrowing, METH_VARARGS, "Regiongrowing(Row,Column,Tolerance,MinSize)\n\nSegment an image using regiongrowing." },
    {"DiffOfGauss", (PyCFunction)PyHirschImage_DiffOfGauss, METH_VARARGS, "DiffOfGauss(Sigma,SigFactor)\n\nApproximate the LoG operator (Laplace of Gaussian)." },
    {"GrayErosion", (PyCFunction)PyHirschImage_GrayErosion, METH_VARARGS, "GrayErosion(SE)\n\nPerform a gray value erosion on an image." },
    {"GrayHistoAbs", (PyCFunction)PyHirschImage_GrayHistoAbs, METH_VARARGS, "GrayHistoAbs(Regions,Quantization)\n\nCalculate the gray value distribution." },
    {"GenImageProto", (PyCFunction)PyHirschImage_GenImageProto, METH_VARARGS, "GenImageProto(Grayval)\n\nCreate an image with a specified constant gray value." },
    {"GrayErosionRect", (PyCFunction)PyHirschImage_GrayErosionRect, METH_VARARGS, "GrayErosionRect(MaskHeight,MaskWidth)\n\nDetermine the minimum gray value within a rectangle." },
    {"Symmetry", (PyCFunction)PyHirschImage_Symmetry, METH_VARARGS, "Symmetry(MaskSize,Direction,Exponent)\n\nSymmetry of gray values along a row." },
    {"GenGaussPyramid", (PyCFunction)PyHirschImage_GenGaussPyramid, METH_VARARGS, "GenGaussPyramid(Mode,Scale)\n\nCalculating a Gauss pyramid." },
    {"EstimateTiltZc", (PyCFunction)PyHirschImage_EstimateTiltZc, METH_NOARGS, "EstimateTiltZc()\n\nEstimate the tilt of a light source." },
    {"MatchEssentialMatrixRansac", (PyCFunction)PyHirschImage_MatchEssentialMatrixRansac, METH_VARARGS, "MatchEssentialMatrixRansac(Image2,Rows1,Cols1,Rows2,Cols2,CamMat1,CamMat2,GrayMatchMethod,MaskSize,RowMove,ColMove,RowTolerance,ColTolerance,Rotation,MatchThreshold,EstimationMethod,DistanceThreshold,RandSeed)\n\nCompute the essential matrix for a pair of stereo images by automatically finding correspondences between image points." },
    {"DivImage", (PyCFunction)PyHirschImage_DivImage, METH_VARARGS, "DivImage(Image2,Mult,Add)\n\nDivide two images." },
    {"SfsPentland", (PyCFunction)PyHirschImage_SfsPentland, METH_VARARGS, "SfsPentland(Slant,Tilt,Albedo,Ambient)\n\nReconstruct a surface from a gray value image." },
    {"GrayOpeningRect", (PyCFunction)PyHirschImage_GrayOpeningRect, METH_VARARGS, "GrayOpeningRect(MaskHeight,MaskWidth)\n\nPerform a gray value opening with a rectangular mask." },
    {"PhaseRad", (PyCFunction)PyHirschImage_PhaseRad, METH_NOARGS, "PhaseRad()\n\nReturn the phase of a complex image in radians." },
    {"FastThreshold", (PyCFunction)PyHirschImage_FastThreshold, METH_VARARGS, "FastThreshold(MinGray,MaxGray,MinSize)\n\nFast thresholding of images using global thresholds." },
    {"GenImageConst", (PyCFunction)PyHirschImage_GenImageConst, METH_VARARGS, "GenImageConst(Type,Width,Height)\n\nCreate an image with constant gray value." },
    {"AddNoiseWhite", (PyCFunction)PyHirschImage_AddNoiseWhite, METH_VARARGS, "AddNoiseWhite(Amp)\n\nAdd noise to an image." },
    {"LocalMax", (PyCFunction)PyHirschImage_LocalMax, METH_NOARGS, "LocalMax()\n\nDetect all local maxima in an image." },
    {"EliminateMinMax", (PyCFunction)PyHirschImage_EliminateMinMax, METH_VARARGS, "EliminateMinMax(MaskWidth,MaskHeight,Gap,Mode)\n\nSmooth an image in the spatial domain to suppress noise." },
    {"OpticalFlowMg", (PyCFunction)PyHirschImage_OpticalFlowMg, METH_VARARGS, "OpticalFlowMg(ImageT2,Algorithm,SmoothingSigma,IntegrationSigma,FlowSmoothness,GradientConstancy,MGParamName,MGParamValue)\n\nCompute the optical flow between two images." },
    {"RotateImage", (PyCFunction)PyHirschImage_RotateImage, METH_VARARGS, "RotateImage(Phi,Interpolation)\n\nRotate an image about its center." },
    {"VectorFieldToHomMat2d", (PyCFunction)PyHirschImage_VectorFieldToHomMat2d, METH_NOARGS, "VectorFieldToHomMat2d()\n\nApproximate an affine map from a displacement vector field." },
    {"CorrelationFft", (PyCFunction)PyHirschImage_CorrelationFft, METH_VARARGS, "CorrelationFft(ImageFFT2)\n\nCompute the correlation of two images in the frequency domain." },
    {"VarThreshold", (PyCFunction)PyHirschImage_VarThreshold, METH_VARARGS, "VarThreshold(MaskWidth,MaskHeight,StdDevScale,AbsThreshold,LightDark)\n\nThreshold an image by local mean and standard deviation analysis." },
    {"LinesColor", (PyCFunction)PyHirschImage_LinesColor, METH_VARARGS, "LinesColor(Sigma,Low,High,ExtractWidth,CompleteJunctions)\n\nDetect color lines and their width." },
    {"GenGabor", (PyCFunction)PyHirschImage_GenGabor, METH_VARARGS, "GenGabor(Angle,Frequency,Bandwidth,Orientation,Norm,Mode,Width,Height)\n\nGenerate a Gabor filter." },
    {"PaintRegion", (PyCFunction)PyHirschImage_PaintRegion, METH_VARARGS, "PaintRegion(Region,Grayval,Type)\n\nPaint regions into an image." },
    {"BestMatchPreMg", (PyCFunction)PyHirschImage_BestMatchPreMg, METH_VARARGS, "BestMatchPreMg(TemplateID,MaxError,SubPixel,NumLevels,WhichLevels)\n\nSearching the best grayvalue matches in a pre generated pyramid." },
    {"RealToComplex", (PyCFunction)PyHirschImage_RealToComplex, METH_VARARGS, "RealToComplex(ImageImaginary)\n\nConvert two real images into a complex image." },
    {"CropRectangle1", (PyCFunction)PyHirschImage_CropRectangle1, METH_VARARGS, "CropRectangle1(Row1,Column1,Row2,Column2)\n\nCut out one or more rectangular image areas." },
    {"ChangeDomain", (PyCFunction)PyHirschImage_ChangeDomain, METH_VARARGS, "ChangeDomain(NewDomain)\n\nChange definition domain of an image." },
    {"InpaintingCt", (PyCFunction)PyHirschImage_InpaintingCt, METH_VARARGS, "InpaintingCt(Region,Epsilon,Kappa,Sigma,Rho,ChannelCoefficients)\n\nPerform an inpainting by coherence transport." },
    {"MaxImage", (PyCFunction)PyHirschImage_MaxImage, METH_VARARGS, "MaxImage(Image2)\n\nCalculate the maximum of two images pixel by pixel." },
    {"ConvolFft", (PyCFunction)PyHirschImage_ConvolFft, METH_VARARGS, "ConvolFft(ImageFilter)\n\nConvolve an image with a filter in the frequency domain." },
    {"ImageToChannels", (PyCFunction)PyHirschImage_ImageToChannels, METH_NOARGS, "ImageToChannels()\n\nConvert a multi-channel image into One-channel images" },
    {"MedianWeighted", (PyCFunction)PyHirschImage_MedianWeighted, METH_VARARGS, "MedianWeighted(MaskType,MaskSize)\n\nWeighted median filtering with different rank masks." },
    {"EdgesSubPix", (PyCFunction)PyHirschImage_EdgesSubPix, METH_VARARGS, "EdgesSubPix(Filter,Alpha,Low,High)\n\nExtract sub-pixel precise edges using Deriche, Lanser, Shen, or Canny filters." },
    {"GammaImage", (PyCFunction)PyHirschImage_GammaImage, METH_VARARGS, "GammaImage(Gamma,Offset,Threshold,MaxGray,Encode)\n\nPerform a gamma encoding or decoding of an image." },
    {"Monotony", (PyCFunction)PyHirschImage_Monotony, METH_NOARGS, "Monotony()\n\nCalculating the monotony operation." },
    {"RegiongrowingMean", (PyCFunction)PyHirschImage_RegiongrowingMean, METH_VARARGS, "RegiongrowingMean(StartRows,StartColumns,Tolerance,MinSize)\n\nPerform a regiongrowing using mean gray values." },
    {"GenInitialComponents", (PyCFunction)PyHirschImage_GenInitialComponents, METH_VARARGS, "GenInitialComponents(ContrastLow,ContrastHigh,MinSize,Mode,GenericName,GenericValue)\n\nExtract the initial components of a component model." },
    {"SfsOrigLr", (PyCFunction)PyHirschImage_SfsOrigLr, METH_VARARGS, "SfsOrigLr(Slant,Tilt,Albedo,Ambient)\n\nReconstruct a surface from a gray value image." },
    {"ExhaustiveMatchMg", (PyCFunction)PyHirschImage_ExhaustiveMatchMg, METH_VARARGS, "ExhaustiveMatchMg(ImageTemplate,Mode,Level,Threshold)\n\nMatching a template and an image in a resolution pyramid." },
    {"AccessChannel", (PyCFunction)PyHirschImage_AccessChannel, METH_VARARGS, "AccessChannel(Channel)\n\nAccess a channel of a multi-channel image." },
    {"EstimateSlAlZc", (PyCFunction)PyHirschImage_EstimateSlAlZc, METH_NOARGS, "EstimateSlAlZc()\n\nEstimate the slant of a light source and the albedo of a surface." },
    {"GenImageSurfaceSecondOrder", (PyCFunction)PyHirschImage_GenImageSurfaceSecondOrder, METH_VARARGS, "GenImageSurfaceSecondOrder(Type,Alpha,Beta,Gamma,Delta,Epsilon,Zeta,Row,Column,Width,Height)\n\nCreate a curved gray surface with second order polynomial." },
    {"HoughLineTransDir", (PyCFunction)PyHirschImage_HoughLineTransDir, METH_VARARGS, "HoughLineTransDir(DirectionUncertainty,AngleResolution)\n\nCompute the Hough transform for lines using local gradient direction." },
    {"InterleaveChannels", (PyCFunction)PyHirschImage_InterleaveChannels, METH_VARARGS, "InterleaveChannels(PixelFormat,RowBytes,Alpha)\n\nCreate an interleaved image from a multichannel image." },
    {"MedianImage", (PyCFunction)PyHirschImage_MedianImage, METH_VARARGS, "MedianImage(MaskType,Radius,Margin)\n\nCompute a median filter with various masks." },
    {"InpaintingMcf", (PyCFunction)PyHirschImage_InpaintingMcf, METH_VARARGS, "InpaintingMcf(Region,Sigma,Theta,Iterations)\n\nPerform an inpainting by smoothing of level lines." },
    {"ReadOcrTrainf", (PyCFunction)PyHirschImage_ReadOcrTrainf, METH_VARARGS, "ReadOcrTrainf(TrainingFile)\n\nRead training characters from files and convert to images." },
    {"Emphasize", (PyCFunction)PyHirschImage_Emphasize, METH_VARARGS, "Emphasize(MaskWidth,MaskHeight,Factor)\n\nEnhance contrast of the image." },
    {"LinearTransColor", (PyCFunction)PyHirschImage_LinearTransColor, METH_VARARGS, "LinearTransColor(TransMat)\n\nCompute an affine transformation of the color values of a multichannel image." },
    {"InpaintingCed", (PyCFunction)PyHirschImage_InpaintingCed, METH_VARARGS, "InpaintingCed(Region,Sigma,Rho,Theta,Iterations)\n\nPerform an inpainting by coherence enhancing diffusion." },
    {"UnwarpImageVectorField", (PyCFunction)PyHirschImage_UnwarpImageVectorField, METH_VARARGS, "UnwarpImageVectorField(VectorField)\n\nUnwarp an image using a vector field." },
    {"PolarTransImage", (PyCFunction)PyHirschImage_PolarTransImage, METH_VARARGS, "PolarTransImage(Row,Column,Width,Height)\n\nTransform an image to polar coordinates" },
    {"GenGaussFilter", (PyCFunction)PyHirschImage_GenGaussFilter, METH_VARARGS, "GenGaussFilter(Sigma1,Sigma2,Phi,Norm,Mode,Width,Height)\n\nGenerate a Gaussian filter in the frequency domain." },
    {"SelectObj", (PyCFunction)PyHirschImage_SelectObj, METH_VARARGS, "SelectObj(Index)\n\nSelect objects from an object tuple." },
    {"MedianSeparate", (PyCFunction)PyHirschImage_MedianSeparate, METH_VARARGS, "MedianSeparate(MaskWidth,MaskHeight,Margin)\n\nSeparated median filtering with rectangle masks." },
    {"GetImagePointer1Rect", (PyCFunction)PyHirschImage_GetImagePointer1Rect, METH_NOARGS, "GetImagePointer1Rect()\n\nAccess to the image data pointer and the image data inside the smallest rectangle of the domain of the input image." },
    {"Clone", (PyCFunction)PyHirschImage_Clone, METH_NOARGS, "Clone()\n\nDeep copy of all data represented by this object instance" },
    {"CopyObj", (PyCFunction)PyHirschImage_CopyObj, METH_VARARGS, "CopyObj(Index,NumObj)\n\nCopy an iconic object in the HALCON database." },
    {"BitNot", (PyCFunction)PyHirschImage_BitNot, METH_NOARGS, "BitNot()\n\nComplement all bits of the pixels." },
    {"FftGeneric", (PyCFunction)PyHirschImage_FftGeneric, METH_VARARGS, "FftGeneric(Direction,Exponent,Norm,Mode,ResultType)\n\nCompute the fast Fourier transform of an image." },
    {"BitXor", (PyCFunction)PyHirschImage_BitXor, METH_VARARGS, "BitXor(Image2)\n\nBit-by-bit XOR of all pixels of the input images." },
    {"RegionToMean", (PyCFunction)PyHirschImage_RegionToMean, METH_VARARGS, "RegionToMean(Regions)\n\nPaint regions with their average gray value." },
    {"CoherenceEnhancingDiff", (PyCFunction)PyHirschImage_CoherenceEnhancingDiff, METH_VARARGS, "CoherenceEnhancingDiff(Sigma,Rho,Theta,Iterations)\n\nPerform a coherence enhancing diffusion of an image." },
    {"FindDataCode2d", (PyCFunction)PyHirschImage_FindDataCode2d, METH_VARARGS, "FindDataCode2d(DataCodeHandle,GenParamName,GenParamValue)\n\nDetect and read 2D data code symbols in an image or train the 2D data code model." },
    {"SegmentImageMser", (PyCFunction)PyHirschImage_SegmentImageMser, METH_VARARGS, "SegmentImageMser(Polarity,MinArea,MaxArea,Delta,GenParamName,GenParamValue)\n\nSegment image using Maximally Stable Extremal Regions (MSER)." },
    {"LogImage", (PyCFunction)PyHirschImage_LogImage, METH_VARARGS, "LogImage(Base)\n\nCalculate the logarithm of an image." },
    {"SimulateDefocus", (PyCFunction)PyHirschImage_SimulateDefocus, METH_VARARGS, "SimulateDefocus(Blurring)\n\nSimulate an uniform out-of-focus blurring of an image." },
    {"GenFilterMask", (PyCFunction)PyHirschImage_GenFilterMask, METH_VARARGS, "GenFilterMask(FilterMask,Scale,Width,Height)\n\nStore a filter mask in the spatial domain as a real-image." },
    {"OverpaintGray", (PyCFunction)PyHirschImage_OverpaintGray, METH_VARARGS, "OverpaintGray(ImageSource)\n\nOverpaint the gray values of an image." },
    {"CfaToRgb", (PyCFunction)PyHirschImage_CfaToRgb, METH_VARARGS, "CfaToRgb(CFAType,Interpolation)\n\nConvert a single-channel color filter array image into an RGB image." },
    {"AsinImage", (PyCFunction)PyHirschImage_AsinImage, METH_NOARGS, "AsinImage()\n\nCalculate the arcsine of an image." },
    {"GenLowpass", (PyCFunction)PyHirschImage_GenLowpass, METH_VARARGS, "GenLowpass(Frequency,Norm,Mode,Width,Height)\n\nGenerate an ideal lowpass filter." },
    {"TrimmedMean", (PyCFunction)PyHirschImage_TrimmedMean, METH_VARARGS, "TrimmedMean(Mask,Number,Margin)\n\nSmooth an image with an arbitrary rank mask." },
    {"ProjMatchPointsRansacGuided", (PyCFunction)PyHirschImage_ProjMatchPointsRansacGuided, METH_VARARGS, "ProjMatchPointsRansacGuided(Image2,Rows1,Cols1,Rows2,Cols2,GrayMatchMethod,MaskSize,HomMat2DGuide,DistanceTolerance,MatchThreshold,EstimationMethod,DistanceThreshold,RandSeed)\n\nCompute a projective transformation matrix between two images by finding correspondences between points based on a known approximation of the projective transformation matrix." },
    {"Width", (PyCFunction)PyHirschImage_Width, METH_NOARGS, "Width()\n\nThe area of the region" },
    {"AreaCenterGray", (PyCFunction)PyHirschImage_AreaCenterGray, METH_VARARGS, "AreaCenterGray(Regions)\n\nCompute the area and center of gravity of a region in a gray value image." },
    {"TileChannels", (PyCFunction)PyHirschImage_TileChannels, METH_VARARGS, "TileChannels(NumColumns,TileOrder)\n\nTile multiple images into a large image." },
    {"MomentsGrayPlane", (PyCFunction)PyHirschImage_MomentsGrayPlane, METH_VARARGS, "MomentsGrayPlane(Regions)\n\nCalculate gray value moments and approximation by a plane." },
    {"MatchFundamentalMatrixDistortionRansac", (PyCFunction)PyHirschImage_MatchFundamentalMatrixDistortionRansac, METH_VARARGS, "MatchFundamentalMatrixDistortionRansac(Image2,Rows1,Cols1,Rows2,Cols2,GrayMatchMethod,MaskSize,RowMove,ColMove,RowTolerance,ColTolerance,Rotation,MatchThreshold,EstimationMethod,DistanceThreshold,RandSeed)\n\nCompute the fundamental matrix and the radial distortion coefficient for a pair of stereo images by automatically finding correspondences between image points." },
    {"BinomialFilter", (PyCFunction)PyHirschImage_BinomialFilter, METH_VARARGS, "BinomialFilter(MaskWidth,MaskHeight)\n\nSmooth an image using the binomial filter." },
    {"HighpassImage", (PyCFunction)PyHirschImage_HighpassImage, METH_VARARGS, "HighpassImage(Width,Height)\n\nExtract high frequency components from an image." },
    {"PrincipalComp", (PyCFunction)PyHirschImage_PrincipalComp, METH_NOARGS, "PrincipalComp()\n\nCompute the principal components of multichannel images." },
    {"GenSphericalMosaic", (PyCFunction)PyHirschImage_GenSphericalMosaic, METH_VARARGS, "GenSphericalMosaic(CameraMatrices,RotationMatrices,LatMin,LatMax,LongMin,LongMax,LatLongStep,StackingOrder,Interpolation)\n\nCreate a spherical mosaic image." },
    {"GetGrayvalInterpolated", (PyCFunction)PyHirschImage_GetGrayvalInterpolated, METH_VARARGS, "GetGrayvalInterpolated(Row,Column,Interpolation)\n\nReturn gray values of an image at the positions given by tuples of rows and columns." },
    {"PlateausCenter", (PyCFunction)PyHirschImage_PlateausCenter, METH_NOARGS, "PlateausCenter()\n\nDetect the centers of all gray value plateaus." },
    {"PowImage", (PyCFunction)PyHirschImage_PowImage, METH_VARARGS, "PowImage(Exponent)\n\nRaise an image to a power." },
    {"ConnectGridPoints", (PyCFunction)PyHirschImage_ConnectGridPoints, METH_VARARGS, "ConnectGridPoints(Row,Column,Sigma,MaxDist)\n\nEstablish connections between the grid points of the rectification grid." },
    {"PrewittAmp", (PyCFunction)PyHirschImage_PrewittAmp, METH_NOARGS, "PrewittAmp()\n\nDetect edges (amplitude) using the Prewitt operator." },
    {"AbsImage", (PyCFunction)PyHirschImage_AbsImage, METH_NOARGS, "AbsImage()\n\nCalculate the absolute value (modulus) of an image." },
    {"DepthFromFocus", (PyCFunction)PyHirschImage_DepthFromFocus, METH_VARARGS, "DepthFromFocus(Filter,Selection)\n\nExtract depth using multiple focus levels." },
    {"ComplexToReal", (PyCFunction)PyHirschImage_ComplexToReal, METH_NOARGS, "ComplexToReal()\n\nConvert a complex image into two real images." },
    {"DetermineDeformableModelParams", (PyCFunction)PyHirschImage_DetermineDeformableModelParams, METH_VARARGS, "DetermineDeformableModelParams(NumLevels,AngleStart,AngleExtent,ScaleMin,ScaleMax,Optimization,Metric,Contrast,MinContrast,GenParamName,GenParamValue,Parameters)\n\nDetermine the parameters of a deformable model." },
    {"GenProjectiveMosaic", (PyCFunction)PyHirschImage_GenProjectiveMosaic, METH_VARARGS, "GenProjectiveMosaic(StartImage,MappingSource,MappingDest,HomMatrices2D,StackingOrder,TransformDomain)\n\nCombine multiple images into a mosaic image." },
    {"SmoothImage", (PyCFunction)PyHirschImage_SmoothImage, METH_VARARGS, "SmoothImage(Filter,Alpha)\n\nSmooth an image using various filters." },
    {"FreiAmp", (PyCFunction)PyHirschImage_FreiAmp, METH_NOARGS, "FreiAmp()\n\nDetect edges (amplitude) using the Frei-Chen operator." },
    {"Intensity", (PyCFunction)PyHirschImage_Intensity, METH_VARARGS, "Intensity(Regions)\n\nCalculate the mean and deviation of gray values." },
    {"Class2dimUnsup", (PyCFunction)PyHirschImage_Class2dimUnsup, METH_VARARGS, "Class2dimUnsup(Image2,Threshold,NumClasses)\n\nSegment two images by clustering." },
    {"IsotropicDiffusion", (PyCFunction)PyHirschImage_IsotropicDiffusion, METH_VARARGS, "IsotropicDiffusion(Sigma,Iterations)\n\nPerform an isotropic diffusion of an image." },
    {"Rectangle1Domain", (PyCFunction)PyHirschImage_Rectangle1Domain, METH_VARARGS, "Rectangle1Domain(Row1,Column1,Row2,Column2)\n\nReduce the domain of an image to a rectangle." },
    {"TileImagesOffset", (PyCFunction)PyHirschImage_TileImagesOffset, METH_VARARGS, "TileImagesOffset(OffsetRow,OffsetCol,Row1,Col1,Row2,Col2,Width,Height)\n\nTile multiple image objects into a large image with explicit positioning information." },
    {"RobinsonAmp", (PyCFunction)PyHirschImage_RobinsonAmp, METH_NOARGS, "RobinsonAmp()\n\nDetect edges (amplitude) using the Robinson operator." },
    {"LocalMin", (PyCFunction)PyHirschImage_LocalMin, METH_NOARGS, "LocalMin()\n\nDetect all local minima in an image." },
    {"SqrtImage", (PyCFunction)PyHirschImage_SqrtImage, METH_NOARGS, "SqrtImage()\n\nCalculate the square root of an image." },
    {"GetImageTime", (PyCFunction)PyHirschImage_GetImageTime, METH_NOARGS, "GetImageTime()\n\nRequest time at which the image was created." },
    {"GenBinocularProjRectification", (PyCFunction)PyHirschImage_GenBinocularProjRectification, METH_VARARGS, "GenBinocularProjRectification(FMatrix,CovFMat,Width1,Height1,Width2,Height2,SubSampling,Mapping)\n\nCompute the projective rectification of weakly calibrated binocular stereo images." },
    {"PointsHarris", (PyCFunction)PyHirschImage_PointsHarris, METH_VARARGS, "PointsHarris(SigmaGrad,SigmaSmooth,Alpha,Threshold)\n\nDetect points of interest using the Harris operator." },
    {"GetImageType", (PyCFunction)PyHirschImage_GetImageType, METH_NOARGS, "GetImageType()\n\nReturn the type of an image." },
    {"CountChannels", (PyCFunction)PyHirschImage_CountChannels, METH_NOARGS, "CountChannels()\n\nCount channels of image." },
    {"GenImageSurfaceFirstOrder", (PyCFunction)PyHirschImage_GenImageSurfaceFirstOrder, METH_VARARGS, "GenImageSurfaceFirstOrder(Type,Alpha,Beta,Gamma,Row,Column,Width,Height)\n\nCreate a tilted gray surface with first order polynomial." },
    {"WienerFilterNi", (PyCFunction)PyHirschImage_WienerFilterNi, METH_VARARGS, "WienerFilterNi(Psf,NoiseRegion,MaskWidth,MaskHeight)\n\nImage restoration by Wiener filtering." },
    {"Plateaus", (PyCFunction)PyHirschImage_Plateaus, METH_NOARGS, "Plateaus()\n\nDetect all gray value plateaus." },
    {"GenPsfMotion", (PyCFunction)PyHirschImage_GenPsfMotion, METH_VARARGS, "GenPsfMotion(PSFwidth,PSFheight,Blurring,Angle,Type)\n\nGenerate an impulse response of a (linearly) motion blurring." },
    {"SetGrayval", (PyCFunction)PyHirschImage_SetGrayval, METH_VARARGS, "SetGrayval(Row,Column,Grayval)\n\nSet single gray values in an image." },
    {"ReduceDomain", (PyCFunction)PyHirschImage_ReduceDomain, METH_VARARGS, "ReduceDomain(Region)\n\nReduce the domain of an image." },
    {"ExpandGray", (PyCFunction)PyHirschImage_ExpandGray, METH_VARARGS, "ExpandGray(Regions,ForbiddenArea,Iterations,Mode,Threshold)\n\nFill gaps between regions (depending on gray value or color) or split overlapping regions." },
    {"GenBundleAdjustedMosaic", (PyCFunction)PyHirschImage_GenBundleAdjustedMosaic, METH_VARARGS, "GenBundleAdjustedMosaic(HomMatrices2D,StackingOrder,TransformDomain)\n\nCombine multiple images into a mosaic image." },
    {"GrayDilationShape", (PyCFunction)PyHirschImage_GrayDilationShape, METH_VARARGS, "GrayDilationShape(MaskHeight,MaskWidth,MaskShape)\n\nDetermine the maximum gray value within a selected mask." },
    {"MeanSp", (PyCFunction)PyHirschImage_MeanSp, METH_VARARGS, "MeanSp(MaskWidth,MaskHeight,MinThresh,MaxThresh)\n\nSuppress salt and pepper noise." },
    {"WriteOcrTrainfImage", (PyCFunction)PyHirschImage_WriteOcrTrainfImage, METH_VARARGS, "WriteOcrTrainfImage(Class,TrainingFile)\n\nWrite characters into a training file." },
    {"GrayTophat", (PyCFunction)PyHirschImage_GrayTophat, METH_VARARGS, "GrayTophat(SE)\n\nPerform a gray value top hat transformation on an image." },
    {"GaussImage", (PyCFunction)PyHirschImage_GaussImage, METH_VARARGS, "GaussImage(Size)\n\nSmooth an image using discrete Gaussian functions." },
    {"DeviationN", (PyCFunction)PyHirschImage_DeviationN, METH_NOARGS, "DeviationN()\n\nCalculate standard deviation over several channels." },
    {"GenBandfilter", (PyCFunction)PyHirschImage_GenBandfilter, METH_VARARGS, "GenBandfilter(MinFrequency,MaxFrequency,Norm,Mode,Width,Height)\n\nGenerate an ideal band filter." },
    {"AppendChannel", (PyCFunction)PyHirschImage_AppendChannel, METH_VARARGS, "AppendChannel(Image)\n\nAppend additional matrices (channels) to the image." },
    {"GenPsfDefocus", (PyCFunction)PyHirschImage_GenPsfDefocus, METH_VARARGS, "GenPsfDefocus(PSFwidth,PSFheight,Blurring)\n\nGenerate an impulse response of an uniform out-of-focus blurring." },
    {"ZoomImageFactor", (PyCFunction)PyHirschImage_ZoomImageFactor, METH_VARARGS, "ZoomImageFactor(ScaleWidth,ScaleHeight,Interpolation)\n\nZoom an image by a given factor." },
    {"ExhaustiveMatch", (PyCFunction)PyHirschImage_ExhaustiveMatch, METH_VARARGS, "ExhaustiveMatch(RegionOfInterest,ImageTemplate,Mode)\n\nMatching of a template and an image." },
    {"WriteImage", (PyCFunction)PyHirschImage_WriteImage, METH_VARARGS, "WriteImage(Format,FillColor,FileName)\n\nWrite images in graphic formats." },
    {"ZeroCrossing", (PyCFunction)PyHirschImage_ZeroCrossing, METH_NOARGS, "ZeroCrossing()\n\nExtract zero crossings from an image." },
    {"GrayClosingRect", (PyCFunction)PyHirschImage_GrayClosingRect, METH_VARARGS, "GrayClosingRect(MaskHeight,MaskWidth)\n\nPerform a gray value closing with a rectangular mask." },
    {"AffineTransImageSize", (PyCFunction)PyHirschImage_AffineTransImageSize, METH_VARARGS, "AffineTransImageSize(HomMat2D,Interpolation,Width,Height)\n\nApply an arbitrary affine 2D transformation to an image and specify the output image size." },
    {"GenDiscSe", (PyCFunction)PyHirschImage_GenDiscSe, METH_VARARGS, "GenDiscSe(Type,Width,Height,Smax)\n\nGenerate ellipsoidal structuring elements for gray morphology." },
    {"BinaryThreshold", (PyCFunction)PyHirschImage_BinaryThreshold, METH_VARARGS, "BinaryThreshold(Method,LightDark)\n\nSegment an image using binary thresholding." },
    {"KirschDir", (PyCFunction)PyHirschImage_KirschDir, METH_NOARGS, "KirschDir()\n\nDetect edges (amplitude and direction) using the Kirsch operator." },
    {"LinesFacet", (PyCFunction)PyHirschImage_LinesFacet, METH_VARARGS, "LinesFacet(MaskSize,Low,High,LightDark)\n\nDetection of lines using the facet model." },
    {"FreiDir", (PyCFunction)PyHirschImage_FreiDir, METH_NOARGS, "FreiDir()\n\nDetect edges (amplitude and direction) using the Frei-Chen operator." },
    {"TanImage", (PyCFunction)PyHirschImage_TanImage, METH_NOARGS, "TanImage()\n\nCalculate the tangent of an image." },
    {"GrayDilationRect", (PyCFunction)PyHirschImage_GrayDilationRect, METH_VARARGS, "GrayDilationRect(MaskHeight,MaskWidth)\n\nDetermine the maximum gray value within a rectangle." },
    {"GrayOpening", (PyCFunction)PyHirschImage_GrayOpening, METH_VARARGS, "GrayOpening(SE)\n\nPerform a gray value opening on an image." },
    {"ZoomImageSize", (PyCFunction)PyHirschImage_ZoomImageSize, METH_VARARGS, "ZoomImageSize(Width,Height,Interpolation)\n\nZoom an image to a given size." },
    {"CharThreshold", (PyCFunction)PyHirschImage_CharThreshold, METH_VARARGS, "CharThreshold(HistoRegion,Sigma,Percent)\n\nPerform a threshold segmentation for extracting characters." },
    {"SinImage", (PyCFunction)PyHirschImage_SinImage, METH_NOARGS, "SinImage()\n\nCalculate the sine of an image." },
    {"SceneFlowUncalib", (PyCFunction)PyHirschImage_SceneFlowUncalib, METH_VARARGS, "SceneFlowUncalib(ImageRect2T1,ImageRect1T2,ImageRect2T2,Disparity,SmoothingFlow,SmoothingDisparity,GenParamName,GenParamValue)\n\nCompute the uncalibrated scene flow between two stereo image pairs." },
    {"AtanImage", (PyCFunction)PyHirschImage_AtanImage, METH_NOARGS, "AtanImage()\n\nCalculate the arctangent of an image." },
    {"ScaleImageMax", (PyCFunction)PyHirschImage_ScaleImageMax, METH_NOARGS, "ScaleImageMax()\n\nMaximum gray value spreading in the value range 0 to 255." },
    {"BitRshift", (PyCFunction)PyHirschImage_BitRshift, METH_VARARGS, "BitRshift(Shift)\n\nRight shift of all pixels of the image." },
    {"ExpandLine", (PyCFunction)PyHirschImage_ExpandLine, METH_VARARGS, "ExpandLine(Coordinate,ExpandType,RowColumn,Threshold)\n\nExpand a region starting at a given line." },
    {"ChannelsToImage", (PyCFunction)PyHirschImage_ChannelsToImage, METH_NOARGS, "ChannelsToImage()\n\nConvert one-channel images into a multi-channel image" },
    {"BestMatch", (PyCFunction)PyHirschImage_BestMatch, METH_VARARGS, "BestMatch(TemplateID,MaxError,SubPixel)\n\nSearching the best matching of a template and an image." },
    {"InpaintingAniso", (PyCFunction)PyHirschImage_InpaintingAniso, METH_VARARGS, "InpaintingAniso(Region,Mode,Contrast,Theta,Iterations,Rho)\n\nPerform an inpainting by anisotropic diffusion." },
    {"NoiseDistributionMean", (PyCFunction)PyHirschImage_NoiseDistributionMean, METH_VARARGS, "NoiseDistributionMean(ConstRegion,FilterSize)\n\nDetermine the noise distribution of an image." },
    {"ReconstructHeightFieldFromGradient", (PyCFunction)PyHirschImage_ReconstructHeightFieldFromGradient, METH_VARARGS, "ReconstructHeightFieldFromGradient(ReconstructionMethod,GenParamName,GenParamValue)\n\nReconstruct a surface from surface gradients." },
    {"AbsDiffImage", (PyCFunction)PyHirschImage_AbsDiffImage, METH_VARARGS, "AbsDiffImage(Image2,Mult)\n\nCalculate the absolute difference of two images." },
    {"PhaseCorrelationFft", (PyCFunction)PyHirschImage_PhaseCorrelationFft, METH_VARARGS, "PhaseCorrelationFft(ImageFFT2)\n\nCompute the phase correlation of two images in the frequency domain." },
    {"PointsLepetit", (PyCFunction)PyHirschImage_PointsLepetit, METH_VARARGS, "PointsLepetit(Radius,CheckNeighbor,MinCheckNeighborDiff,MinScore,Subpix)\n\nDetect points of interest using the Lepetit operator." },
    {"PaintGray", (PyCFunction)PyHirschImage_PaintGray, METH_VARARGS, "PaintGray(ImageDestination)\n\nPaint the gray values of an image into another image." },
    {"DerivateVectorField", (PyCFunction)PyHirschImage_DerivateVectorField, METH_VARARGS, "DerivateVectorField(Sigma,Component)\n\nConvolve a vector field with derivatives of the Gaussian." },
    {"GetImageSize", (PyCFunction)PyHirschImage_GetImageSize, METH_NOARGS, "GetImageSize()\n\nReturn the size of an image." },
    {"DynThreshold", (PyCFunction)PyHirschImage_DynThreshold, METH_VARARGS, "DynThreshold(ThresholdImage,Offset,LightDark)\n\nSegment an image using a local threshold." },
    {"AutoThreshold", (PyCFunction)PyHirschImage_AutoThreshold, METH_VARARGS, "AutoThreshold(Sigma)\n\nSegment an image using thresholds determined from its histogram." },
    {"EstimateNoise", (PyCFunction)PyHirschImage_EstimateNoise, METH_VARARGS, "EstimateNoise(Method,Percent)\n\nEstimate the image noise from a single image." },
    {"GuidedFilter", (PyCFunction)PyHirschImage_GuidedFilter, METH_VARARGS, "GuidedFilter(ImageGuide,Radius,Amplitude)\n\nGuided filtering of an image." },
    {"LaplaceOfGauss", (PyCFunction)PyHirschImage_LaplaceOfGauss, METH_VARARGS, "LaplaceOfGauss(Sigma)\n\nLoG-Operator (Laplace of Gaussian)." },
    {"CompareObj", (PyCFunction)PyHirschImage_CompareObj, METH_VARARGS, "CompareObj(Objects2,Epsilon)\n\nCompare iconic objects regarding equality." },
    {"Threshold", (PyCFunction)PyHirschImage_Threshold, METH_VARARGS, "Threshold(MinGray,MaxGray)\n\nSegment an image using global threshold." },
    {"ReadOcrTrainfSelect", (PyCFunction)PyHirschImage_ReadOcrTrainfSelect, METH_VARARGS, "ReadOcrTrainfSelect(TrainingFile,SearchNames)\n\nRead training specific characters from files and convert to images." },
    {"ClassNdimNorm", (PyCFunction)PyHirschImage_ClassNdimNorm, METH_VARARGS, "ClassNdimNorm(Metric,SingleMultiple,Radius,Center)\n\nClassify pixels using hyper-spheres or hyper-cubes." },
    {"GenCoocMatrix", (PyCFunction)PyHirschImage_GenCoocMatrix, METH_VARARGS, "GenCoocMatrix(Regions,LdGray,Direction)\n\nCalculate the co-occurrence matrix of a region in an image." },
    {"SobelAmp", (PyCFunction)PyHirschImage_SobelAmp, METH_VARARGS, "SobelAmp(FilterType,Size)\n\nDetect edges (amplitude) using the Sobel operator." },
    {"SfsModLr", (PyCFunction)PyHirschImage_SfsModLr, METH_VARARGS, "SfsModLr(Slant,Tilt,Albedo,Ambient)\n\nReconstruct a surface from a gray value image." },
    {"PointsHarrisBinomial", (PyCFunction)PyHirschImage_PointsHarrisBinomial, METH_VARARGS, "PointsHarrisBinomial(MaskSizeGrad,MaskSizeSmooth,Alpha,Threshold,Subpix)\n\nDetect points of interest using the binomial approximation of the Harris operator." },
    {"MinMaxGray", (PyCFunction)PyHirschImage_MinMaxGray, METH_VARARGS, "MinMaxGray(Regions,Percent)\n\nDetermine the minimum and maximum gray values within regions." },
    {"InspectShapeModel", (PyCFunction)PyHirschImage_InspectShapeModel, METH_VARARGS, "InspectShapeModel(NumLevels,Contrast)\n\nCreate the representation of a shape model." },
    {"PolarTransImageInv", (PyCFunction)PyHirschImage_PolarTransImageInv, METH_VARARGS, "PolarTransImageInv(Row,Column,AngleStart,AngleEnd,RadiusStart,RadiusEnd,Width,Height,Interpolation)\n\nTransform an image in polar coordinates back to cartesian coordinates" },
    {"InpaintingTexture", (PyCFunction)PyHirschImage_InpaintingTexture, METH_VARARGS, "InpaintingTexture(Region,MaskSize,SearchSize,Anisotropy,PostIteration,Smoothness)\n\nPerform an inpainting by texture propagation." },
    {"EliminateSp", (PyCFunction)PyHirschImage_EliminateSp, METH_VARARGS, "EliminateSp(MaskWidth,MaskHeight,MinThresh,MaxThresh)\n\nReplace values outside of thresholds with average value." },
    {"LowlandsCenter", (PyCFunction)PyHirschImage_LowlandsCenter, METH_NOARGS, "LowlandsCenter()\n\nDetect the centers of all gray value lowlands." },
    {"BestMatchRotMg", (PyCFunction)PyHirschImage_BestMatchRotMg, METH_VARARGS, "BestMatchRotMg(TemplateID,AngleStart,AngleExtend,MaxError,SubPixel,NumLevels)\n\nSearching the best matching of a template and a pyramid with rotation." },
    {"MinImage", (PyCFunction)PyHirschImage_MinImage, METH_VARARGS, "MinImage(Image2)\n\nCalculate the minimum of two images pixel by pixel." },
    {"GrayHisto", (PyCFunction)PyHirschImage_GrayHisto, METH_VARARGS, "GrayHisto(Regions)\n\nCalculate the gray value distribution." },
    {"CheckDifference", (PyCFunction)PyHirschImage_CheckDifference, METH_VARARGS, "CheckDifference(Pattern,Mode,DiffLowerBound,DiffUpperBound,GrayOffset,AddRow,AddCol)\n\nCompare two images pixel by pixel." },
    {"GenStdBandpass", (PyCFunction)PyHirschImage_GenStdBandpass, METH_VARARGS, "GenStdBandpass(Frequency,Sigma,Type,Norm,Mode,Width,Height)\n\nGenerate a bandpass filter with Gaussian or sinusoidal shape." },
    {"Roberts", (PyCFunction)PyHirschImage_Roberts, METH_VARARGS, "Roberts(FilterType)\n\nDetect edges using the Roberts filter." },
    {"MirrorImage", (PyCFunction)PyHirschImage_MirrorImage, METH_VARARGS, "MirrorImage(Mode)\n\nMirror an image." },
    {"ChangeFormat", (PyCFunction)PyHirschImage_ChangeFormat, METH_VARARGS, "ChangeFormat(Width,Height)\n\nChange image size." },
    {"AdjustMosaicImages", (PyCFunction)PyHirschImage_AdjustMosaicImages, METH_VARARGS, "AdjustMosaicImages(From,To,ReferenceImage,HomMatrices2D,EstimationMethod,EstimateParameters,OECFModel)\n\nApply an automatic color correction to panorama images." },
    {"PolarTransImageExt", (PyCFunction)PyHirschImage_PolarTransImageExt, METH_VARARGS, "PolarTransImageExt(Row,Column,AngleStart,AngleEnd,RadiusStart,RadiusEnd,Width,Height,Interpolation)\n\nTransform an annular arc in an image to polar coordinates." },
    {"ReadGraySe", (PyCFunction)PyHirschImage_ReadGraySe, METH_VARARGS, "ReadGraySe(FileName)\n\nLoad a structuring element for gray morphology." },
    {"FitSurfaceFirstOrder", (PyCFunction)PyHirschImage_FitSurfaceFirstOrder, METH_VARARGS, "FitSurfaceFirstOrder(Regions,Algorithm,Iterations,ClippingFactor)\n\nCalculate gray value moments and approximation by a first order surface (plane)." },
    {"RadiometricSelfCalibration", (PyCFunction)PyHirschImage_RadiometricSelfCalibration, METH_VARARGS, "RadiometricSelfCalibration(ExposureRatios,Features,FunctionType,Smoothness,PolynomialDegree)\n\nPerform a radiometric self-calibration of a camera." },
    {"ExpandDomainGray", (PyCFunction)PyHirschImage_ExpandDomainGray, METH_VARARGS, "ExpandDomainGray(ExpansionRange)\n\nExpand the domain of an image and set the gray values in the expanded domain." },
    {"MeanImage", (PyCFunction)PyHirschImage_MeanImage, METH_VARARGS, "MeanImage(MaskWidth,MaskHeight)\n\nSmooth by averaging." },
    {"EquHistoImage", (PyCFunction)PyHirschImage_EquHistoImage, METH_NOARGS, "EquHistoImage()\n\nHistogram linearization of images" },
    {"EstimateAlAm", (PyCFunction)PyHirschImage_EstimateAlAm, METH_NOARGS, "EstimateAlAm()\n\nEstimate the albedo of a surface and the amount of ambient light." },
    {"MidrangeImage", (PyCFunction)PyHirschImage_MidrangeImage, METH_VARARGS, "MidrangeImage(Mask,Margin)\n\nCalculate the average of maximum and minimum inside any mask." },
    {"Rgb1ToGray", (PyCFunction)PyHirschImage_Rgb1ToGray, METH_NOARGS, "Rgb1ToGray()\n\nTransform an RGB image into a gray scale image." },
    {"BitOr", (PyCFunction)PyHirschImage_BitOr, METH_VARARGS, "BitOr(Image2)\n\nBit-by-bit OR of all pixels of the input images." },
    {"Atan2Image", (PyCFunction)PyHirschImage_Atan2Image, METH_VARARGS, "Atan2Image(ImageX)\n\nCalculate the arctangent of two images." },
    {"WienerFilter", (PyCFunction)PyHirschImage_WienerFilter, METH_VARARGS, "WienerFilter(Psf,FilteredImage)\n\nImage restoration by Wiener filtering." },
    {"AddNoiseDistribution", (PyCFunction)PyHirschImage_AddNoiseDistribution, METH_VARARGS, "AddNoiseDistribution(Distribution)\n\nAdd noise to an image." },
    {"PowerByte", (PyCFunction)PyHirschImage_PowerByte, METH_NOARGS, "PowerByte()\n\nReturn the power spectrum of a complex image." },
    {"RankRect", (PyCFunction)PyHirschImage_RankRect, METH_VARARGS, "RankRect(MaskWidth,MaskHeight,Rank)\n\nCompute a rank filter with rectangular masks." },
    {"BinocularDisparityMg", (PyCFunction)PyHirschImage_BinocularDisparityMg, METH_VARARGS, "BinocularDisparityMg(ImageRect2,GrayConstancy,GradientConstancy,Smoothness,InitialGuess,CalculateScore,MGParamName,MGParamValue)\n\nCompute the disparities of a rectified stereo image pair using multigrid methods." },
    {"MultImage", (PyCFunction)PyHirschImage_MultImage, METH_VARARGS, "MultImage(Image2,Mult,Add)\n\nMultiply two images." },
    {"FftImageInv", (PyCFunction)PyHirschImage_FftImageInv, METH_NOARGS, "FftImageInv()\n\nCompute the inverse fast Fourier transform of an image." },
    {"BinocularDisparityMs", (PyCFunction)PyHirschImage_BinocularDisparityMs, METH_VARARGS, "BinocularDisparityMs(ImageRect2,MinDisparity,MaxDisparity,SurfaceSmoothing,EdgeSmoothing,GenParamName,GenParamValue)\n\nCompute the disparities of a rectified stereo image pair using multi-scanline optimization." },
    {"ObjDiff", (PyCFunction)PyHirschImage_ObjDiff, METH_VARARGS, "ObjDiff(ObjectsSub)\n\nCalculate the difference of two object tuples." },
    {"EdgesColorSubPix", (PyCFunction)PyHirschImage_EdgesColorSubPix, METH_VARARGS, "EdgesColorSubPix(Filter,Alpha,Low,High)\n\nExtract subpixel precise color edges using Deriche, Shen, or Canny filters." },
    {"LinesGauss", (PyCFunction)PyHirschImage_LinesGauss, METH_VARARGS, "LinesGauss(Sigma,Low,High,LightDark,ExtractWidth,LineModel,CompleteJunctions)\n\nDetect lines and their width." },
    {"GrayClosing", (PyCFunction)PyHirschImage_GrayClosing, METH_VARARGS, "GrayClosing(SE)\n\nPerform a gray value closing on an image." },
    {"GenGridRectificationMap", (PyCFunction)PyHirschImage_GenGridRectificationMap, METH_VARARGS, "GenGridRectificationMap(ConnectingLines,GridSpacing,Rotation,Row,Column,MapType)\n\nCompute the mapping between the distorted image and the rectified image based upon the points of a regular grid." },
    {"EllipticAxisGray", (PyCFunction)PyHirschImage_EllipticAxisGray, METH_VARARGS, "EllipticAxisGray(Regions)\n\nCompute the orientation and major axes of a region in a gray value image." },
    {"BinocularDisparity", (PyCFunction)PyHirschImage_BinocularDisparity, METH_VARARGS, "BinocularDisparity(ImageRect2,Method,MaskWidth,MaskHeight,TextureThresh,MinDisparity,MaxDisparity,NumLevels,ScoreThresh,Filter,SubDisparity)\n\nCompute the disparities of a rectified image pair using correlation techniques." },
    {"ProjMatchPointsDistortionRansac", (PyCFunction)PyHirschImage_ProjMatchPointsDistortionRansac, METH_VARARGS, "ProjMatchPointsDistortionRansac(Image2,Rows1,Cols1,Rows2,Cols2,GrayMatchMethod,MaskSize,RowMove,ColMove,RowTolerance,ColTolerance,Rotation,MatchThreshold,EstimationMethod,DistanceThreshold,RandSeed)\n\nCompute a projective transformation matrix between two images and the radial distortion coefficient by automatically finding correspondences between points." },
    {"NonmaxSuppressionDir", (PyCFunction)PyHirschImage_NonmaxSuppressionDir, METH_VARARGS, "NonmaxSuppressionDir(ImgDir,Mode)\n\nSuppress non-maximum points on an edge using a direction image." },
    {"ConvolImage", (PyCFunction)PyHirschImage_ConvolImage, METH_VARARGS, "ConvolImage(FilterMask,Margin)\n\nCalculate the correlation between an image and an arbitrary filter mask" },
    {"Class2dimSup", (PyCFunction)PyHirschImage_Class2dimSup, METH_VARARGS, "Class2dimSup(ImageRow,FeatureSpace)\n\nSegment an image using two-dimensional pixel classification." },
    {"EntropyImage", (PyCFunction)PyHirschImage_EntropyImage, METH_VARARGS, "EntropyImage(Width,Height)\n\nCalculate the entropy of gray values within a rectangular window." },
    {"AddImage", (PyCFunction)PyHirschImage_AddImage, METH_VARARGS, "AddImage(Image2,Mult,Add)\n\nAdd two images." },
    {"EntropyGray", (PyCFunction)PyHirschImage_EntropyGray, METH_VARARGS, "EntropyGray(Regions)\n\nDetermine the entropy and anisotropy of images." },
    {"FitSurfaceSecondOrder", (PyCFunction)PyHirschImage_FitSurfaceSecondOrder, METH_VARARGS, "FitSurfaceSecondOrder(Regions,Algorithm,Iterations,ClippingFactor)\n\nCalculate gray value moments and approximation by a second order surface." },
    {"GenImageGrayRamp", (PyCFunction)PyHirschImage_GenImageGrayRamp, METH_VARARGS, "GenImageGrayRamp(Alpha,Beta,Mean,Row,Column,Width,Height)\n\nCreate a gray value ramp." },
    {"TileImages", (PyCFunction)PyHirschImage_TileImages, METH_VARARGS, "TileImages(NumColumns,TileOrder)\n\nTile multiple image objects into a large image." },
    {"FuzzyEntropy", (PyCFunction)PyHirschImage_FuzzyEntropy, METH_VARARGS, "FuzzyEntropy(Regions,Apar,Cpar)\n\nDetermine the fuzzy entropy of regions." },
    {"WatershedsThreshold", (PyCFunction)PyHirschImage_WatershedsThreshold, METH_VARARGS, "WatershedsThreshold(Threshold)\n\nExtract watershed basins from an image using a threshold." },
    {"FindCaltab", (PyCFunction)PyHirschImage_FindCaltab, METH_VARARGS, "FindCaltab(CalPlateDescr,SizeGauss,MarkThresh,MinDiamMarks)\n\nSegment the region of a standard calibration plate with rectangularly arranged marks in the image." },
    {"GenPrincipalCompTrans", (PyCFunction)PyHirschImage_GenPrincipalCompTrans, METH_NOARGS, "GenPrincipalCompTrans()\n\nCompute the transformation matrix of the principal component analysis of multichannel images." },
    {"GrayBothat", (PyCFunction)PyHirschImage_GrayBothat, METH_VARARGS, "GrayBothat(SE)\n\nPerform a gray value bottom hat transformation on an image." },
    {"Rgb3ToGray", (PyCFunction)PyHirschImage_Rgb3ToGray, METH_VARARGS, "Rgb3ToGray(ImageGreen,ImageBlue)\n\nTransform an RGB image to a gray scale image." },
    {"RftGeneric", (PyCFunction)PyHirschImage_RftGeneric, METH_VARARGS, "RftGeneric(Direction,Norm,ResultType,Width)\n\nCompute the real-valued fast Fourier transform of an image." },
    {"ExpImage", (PyCFunction)PyHirschImage_ExpImage, METH_VARARGS, "ExpImage(Base)\n\nCalculate the exponentiation of an image." },
    {"GrayProjections", (PyCFunction)PyHirschImage_GrayProjections, METH_VARARGS, "GrayProjections(Region,Mode)\n\nCalculate horizontal and vertical gray-value projections." },
    {"ConcatObj", (PyCFunction)PyHirschImage_ConcatObj, METH_VARARGS, "ConcatObj(Objects2)\n\nConcatenate two iconic object tuples." },
    {"TestEqualObj", (PyCFunction)PyHirschImage_TestEqualObj, METH_VARARGS, "TestEqualObj(Objects2)\n\nCompare image objects regarding equality." },
    {"GrayClosingShape", (PyCFunction)PyHirschImage_GrayClosingShape, METH_VARARGS, "GrayClosingShape(MaskHeight,MaskWidth,MaskShape)\n\nPerform a grayvalue closing with a selected mask." },
    {"GenHighpass", (PyCFunction)PyHirschImage_GenHighpass, METH_VARARGS, "GenHighpass(Frequency,Norm,Mode,Width,Height)\n\nGenerate an ideal highpass filter." },
    {"LearnNdimNorm", (PyCFunction)PyHirschImage_LearnNdimNorm, METH_VARARGS, "LearnNdimNorm(Foreground,Background,Metric,Distance,MinNumberPercent)\n\nConstruct classes for class_ndim_norm." },
    {"ConvertMapType", (PyCFunction)PyHirschImage_ConvertMapType, METH_VARARGS, "ConvertMapType(NewType,ImageWidth)\n\nConvert image maps into other map types." },
    {"CoocFeatureMatrix", (PyCFunction)PyHirschImage_CoocFeatureMatrix, METH_NOARGS, "CoocFeatureMatrix()\n\nCalculate gray value features from a co-occurrence matrix." },
    {"PrewittDir", (PyCFunction)PyHirschImage_PrewittDir, METH_NOARGS, "PrewittDir()\n\nDetect edges (amplitude and direction) using the Prewitt operator." },
    {"BitSlice", (PyCFunction)PyHirschImage_BitSlice, METH_VARARGS, "BitSlice(Bit)\n\nExtract a bit from the pixels." },
    {"AnisotropicDiffusion", (PyCFunction)PyHirschImage_AnisotropicDiffusion, METH_VARARGS, "AnisotropicDiffusion(Mode,Contrast,Theta,Iterations)\n\nPerform an anisotropic diffusion of an image." },
    {"MedianRect", (PyCFunction)PyHirschImage_MedianRect, METH_VARARGS, "MedianRect(MaskWidth,MaskHeight)\n\nCompute a median filter with rectangular masks." },
    {"ReadImage", (PyCFunction)PyHirschImage_ReadImage, METH_VARARGS, "ReadImage(FileName)\n\nRead an image with different file formats." },
    {"ReadSequence", (PyCFunction)PyHirschImage_ReadSequence, METH_VARARGS, "ReadSequence(HeaderSize,SourceWidth,SourceHeight,StartRow,StartColumn,DestWidth,DestHeight,PixelType,BitOrder,ByteOrder,Pad,Index,FileName)\n\nRead images." },
    {"LocalMinSubPix", (PyCFunction)PyHirschImage_LocalMinSubPix, METH_VARARGS, "LocalMinSubPix(Filter,Sigma,Threshold)\n\nSubpixel precise detection of local minima in an image." },
    {"BitLshift", (PyCFunction)PyHirschImage_BitLshift, METH_VARARGS, "BitLshift(Shift)\n\nLeft shift of all pixels of the image." },
    {"Decompose5", (PyCFunction)PyHirschImage_Decompose5, METH_NOARGS, "Decompose5()\n\nConvert a five-channel image into five images." },
    {"GrayInside", (PyCFunction)PyHirschImage_GrayInside, METH_NOARGS, "GrayInside()\n\nCalculate the lowest possible gray value on an arbitrary path to the image border for each point in the image." },
    {"RegiongrowingN", (PyCFunction)PyHirschImage_RegiongrowingN, METH_VARARGS, "RegiongrowingN(Metric,MinTolerance,MaxTolerance,MinSize)\n\nSegment an image using regiongrowing for multi-channel images." },
    {"Illuminate", (PyCFunction)PyHirschImage_Illuminate, METH_VARARGS, "Illuminate(MaskWidth,MaskHeight,Factor)\n\nIlluminate image." },
    {"ExpandGrayRef", (PyCFunction)PyHirschImage_ExpandGrayRef, METH_VARARGS, "ExpandGrayRef(Regions,ForbiddenArea,Iterations,Mode,RefGray,Threshold)\n\nFill gaps between regions (depending on gray value or color) or split overlapping regions." },
    {"Decompose3", (PyCFunction)PyHirschImage_Decompose3, METH_NOARGS, "Decompose3()\n\nConvert a three-channel image into three images." },
    {"Watersheds", (PyCFunction)PyHirschImage_Watersheds, METH_NOARGS, "Watersheds()\n\nExtract watersheds and basins from an image." },
    {"RankN", (PyCFunction)PyHirschImage_RankN, METH_VARARGS, "RankN(RankIndex)\n\nReturn gray values with given rank from multiple channels." },
    {"TextureLaws", (PyCFunction)PyHirschImage_TextureLaws, METH_VARARGS, "TextureLaws(FilterTypes,Shift,FilterSize)\n\nFilter an image using a Laws texture filter." },
    {"Decompose7", (PyCFunction)PyHirschImage_Decompose7, METH_NOARGS, "Decompose7()\n\nConvert a seven-channel image into seven images." },
    {"Decompose6", (PyCFunction)PyHirschImage_Decompose6, METH_NOARGS, "Decompose6()\n\nConvert a six-channel image into six images." },
    {"SigmaImage", (PyCFunction)PyHirschImage_SigmaImage, METH_VARARGS, "SigmaImage(MaskHeight,MaskWidth,Sigma)\n\nNon-linear smoothing with the sigma filter." },
    {"Decompose4", (PyCFunction)PyHirschImage_Decompose4, METH_NOARGS, "Decompose4()\n\nConvert a four-channel image into four images." },
    {"CornerResponse", (PyCFunction)PyHirschImage_CornerResponse, METH_VARARGS, "CornerResponse(Size,Weight)\n\nSearching corners in images." },
    {"Decompose2", (PyCFunction)PyHirschImage_Decompose2, METH_NOARGS, "Decompose2()\n\nConvert a two-channel image into two images." },